{"version":3,"sources":["webpack://Phaser2NavMeshPlugin/webpack/universalModuleDefinition","webpack://Phaser2NavMeshPlugin/webpack/bootstrap","webpack://Phaser2NavMeshPlugin/D:/GitHub/navmesh/node_modules/javascript-astar/astar.js","webpack://Phaser2NavMeshPlugin/D:/GitHub/navmesh/packages/navmesh/src/math/vector-2.js","webpack://Phaser2NavMeshPlugin/D:/GitHub/navmesh/packages/navmesh/src/navpoly.js","webpack://Phaser2NavMeshPlugin/D:/GitHub/navmesh/packages/navmesh/src/navgraph.js","webpack://Phaser2NavMeshPlugin/D:/GitHub/navmesh/packages/navmesh/src/utils.js","webpack://Phaser2NavMeshPlugin/D:/GitHub/navmesh/packages/navmesh/src/channel.js","webpack://Phaser2NavMeshPlugin/D:/GitHub/navmesh/packages/navmesh/src/math/line.js","webpack://Phaser2NavMeshPlugin/D:/GitHub/navmesh/packages/navmesh/src/math/polygon.js","webpack://Phaser2NavMeshPlugin/D:/GitHub/navmesh/packages/navmesh/src/navmesh.js","webpack://Phaser2NavMeshPlugin/D:/GitHub/navmesh/packages/navmesh/src/index.js","webpack://Phaser2NavMeshPlugin/./phaser2-navmesh.js","webpack://Phaser2NavMeshPlugin/./phaser2-navmesh-plugin.js","webpack://Phaser2NavMeshPlugin/./index.js"],"names":["Vector2","constructor","x","y","equals","v","angle","Math","atan2","distance","dx","dy","sqrt","add","subtract","clone","NavPoly","id","polygon","edges","neighbors","portals","centroid","calculateCentroid","boundingRadius","calculateRadius","weight","getPoints","points","contains","point","isPointOnEdge","length","forEach","p","d","edge","pointOnSegment","destroy","toString","isWall","centroidDistance","navPolygon","getCost","NavGraph","navPolygons","nodes","init","navHeuristic","navPolygon1","navPolygon2","cleanDirty","prototype","jsastar","Graph","markDirty","triarea2","a","b","c","ax","ay","bx","by","clamp","value","min","max","almostEqual","value1","value2","errorMargin","abs","angleDifference","i","PI","j","floor","areCollinear","line1","line2","area1","start","end","area2","Channel","push","p1","p2","left","right","stringPull","pts","portalApex","portalLeft","portalRight","apexIndex","leftIndex","rightIndex","path","Line","x1","y1","x2","y2","top","bottom","pointOnLine","Polygon","closed","first","last","inside","ix","iy","jx","jy","NavMesh","meshPolygonPoints","meshShrinkAmount","_meshShrinkAmount","newPolys","map","polyPoints","vectors","_navPolygons","_calculateNeighbors","_graph","getPolygons","poly","findPath","startPoint","endPoint","startPoly","endPoly","startDistance","Number","MAX_VALUE","endDistance","r","startVector","endVector","navPoly","_projectPointToPolygon","astarPath","astar","search","heuristic","unshift","channel","nextNavPolygon","portal","lastPoint","phaserPath","newPoint","otherNavPoly","otherEdge","overlap","_getSegmentOverlap","edgeStartAngle","a1","a2","d1","d2","line","sort","noOverlap","singlePointOverlap","closestProjection","closestDistance","projectedPoint","_projectPointToEdge","_distanceSquared","l2","t","Phaser2NavMesh","plugin","key","game","debugGraphics","navMesh","PointClass","Phaser","Point","enableDebug","graphics","visible","disableDebug","isDebugEnabled","debugDrawClear","clear","debugDrawMesh","drawCentroid","drawBounds","drawNeighbors","drawPortals","palette","navPolys","color","lineWidth","beginFill","drawPolygon","endFill","drawEllipse","lineStyle","n","moveTo","lineTo","debugDrawPath","thickness","alpha","drawShape","removeMesh","undefined","scene","Phaser2NavMeshPlugin","Plugin","pluginManager","phaserNavMeshes","meshes","Object","values","m","buildMeshFromTiled","objectLayer","console","warn","objects","polygons","obj","height","width","mesh"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;QCVA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,KAA0B;AAChC;AACA,GAAG,UAAU,IAA0C;AACvD,IAAI,iCAAO,EAAE,oCAAE,UAAU;AAAA;AAAA;AAAA,oGAAC;AAC1B,GAAG,MAAM,gBAIN;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,SAAS;AACrB,YAAY,SAAS;AACrB,YAAY,OAAO;AACnB,YAAY,KAAK;AACjB;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B;;AAE5B;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,4CAA4C,QAAQ;AACpD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,WAAW,KAAK;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,mBAAmB;AACpC;;AAEA,oCAAoC,gBAAgB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,uBAAuB;AACxC;AACA;AACA;;AAEA;AACA,iBAAiB,4BAA4B;AAC7C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAC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","file":"phaser2-navmesh.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Phaser2NavMeshPlugin\"] = factory();\n\telse\n\t\troot[\"Phaser2NavMeshPlugin\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","// javascript-astar 0.4.2\n// http://github.com/bgrins/javascript-astar\n// Freely distributable under the MIT License.\n// Implements the astar search algorithm in javascript using a Binary Heap.\n// Includes Binary Heap (with modifications) from Marijn Haverbeke.\n// http://eloquentjavascript.net/appendix2.html\n(function(definition) {\n  /* global module, define */\n  if (typeof module === 'object' && typeof module.exports === 'object') {\n    module.exports = definition();\n  } else if (typeof define === 'function' && define.amd) {\n    define([], definition);\n  } else {\n    var exports = definition();\n    window.astar = exports.astar;\n    window.Graph = exports.Graph;\n  }\n})(function() {\n\nfunction pathTo(node) {\n  var curr = node;\n  var path = [];\n  while (curr.parent) {\n    path.unshift(curr);\n    curr = curr.parent;\n  }\n  return path;\n}\n\nfunction getHeap() {\n  return new BinaryHeap(function(node) {\n    return node.f;\n  });\n}\n\nvar astar = {\n  /**\n  * Perform an A* Search on a graph given a start and end node.\n  * @param {Graph} graph\n  * @param {GridNode} start\n  * @param {GridNode} end\n  * @param {Object} [options]\n  * @param {bool} [options.closest] Specifies whether to return the\n             path to the closest node if the target is unreachable.\n  * @param {Function} [options.heuristic] Heuristic function (see\n  *          astar.heuristics).\n  */\n  search: function(graph, start, end, options) {\n    graph.cleanDirty();\n    options = options || {};\n    var heuristic = options.heuristic || astar.heuristics.manhattan;\n    var closest = options.closest || false;\n\n    var openHeap = getHeap();\n    var closestNode = start; // set the start node to be the closest if required\n\n    start.h = heuristic(start, end);\n    graph.markDirty(start);\n\n    openHeap.push(start);\n\n    while (openHeap.size() > 0) {\n\n      // Grab the lowest f(x) to process next.  Heap keeps this sorted for us.\n      var currentNode = openHeap.pop();\n\n      // End case -- result has been found, return the traced path.\n      if (currentNode === end) {\n        return pathTo(currentNode);\n      }\n\n      // Normal case -- move currentNode from open to closed, process each of its neighbors.\n      currentNode.closed = true;\n\n      // Find all neighbors for the current node.\n      var neighbors = graph.neighbors(currentNode);\n\n      for (var i = 0, il = neighbors.length; i < il; ++i) {\n        var neighbor = neighbors[i];\n\n        if (neighbor.closed || neighbor.isWall()) {\n          // Not a valid node to process, skip to next neighbor.\n          continue;\n        }\n\n        // The g score is the shortest distance from start to current node.\n        // We need to check if the path we have arrived at this neighbor is the shortest one we have seen yet.\n        var gScore = currentNode.g + neighbor.getCost(currentNode);\n        var beenVisited = neighbor.visited;\n\n        if (!beenVisited || gScore < neighbor.g) {\n\n          // Found an optimal (so far) path to this node.  Take score for node to see how good it is.\n          neighbor.visited = true;\n          neighbor.parent = currentNode;\n          neighbor.h = neighbor.h || heuristic(neighbor, end);\n          neighbor.g = gScore;\n          neighbor.f = neighbor.g + neighbor.h;\n          graph.markDirty(neighbor);\n          if (closest) {\n            // If the neighbour is closer than the current closestNode or if it's equally close but has\n            // a cheaper path than the current closest node then it becomes the closest node\n            if (neighbor.h < closestNode.h || (neighbor.h === closestNode.h && neighbor.g < closestNode.g)) {\n              closestNode = neighbor;\n            }\n          }\n\n          if (!beenVisited) {\n            // Pushing to heap will put it in proper place based on the 'f' value.\n            openHeap.push(neighbor);\n          } else {\n            // Already seen the node, but since it has been rescored we need to reorder it in the heap\n            openHeap.rescoreElement(neighbor);\n          }\n        }\n      }\n    }\n\n    if (closest) {\n      return pathTo(closestNode);\n    }\n\n    // No result was found - empty array signifies failure to find path.\n    return [];\n  },\n  // See list of heuristics: http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html\n  heuristics: {\n    manhattan: function(pos0, pos1) {\n      var d1 = Math.abs(pos1.x - pos0.x);\n      var d2 = Math.abs(pos1.y - pos0.y);\n      return d1 + d2;\n    },\n    diagonal: function(pos0, pos1) {\n      var D = 1;\n      var D2 = Math.sqrt(2);\n      var d1 = Math.abs(pos1.x - pos0.x);\n      var d2 = Math.abs(pos1.y - pos0.y);\n      return (D * (d1 + d2)) + ((D2 - (2 * D)) * Math.min(d1, d2));\n    }\n  },\n  cleanNode: function(node) {\n    node.f = 0;\n    node.g = 0;\n    node.h = 0;\n    node.visited = false;\n    node.closed = false;\n    node.parent = null;\n  }\n};\n\n/**\n * A graph memory structure\n * @param {Array} gridIn 2D array of input weights\n * @param {Object} [options]\n * @param {bool} [options.diagonal] Specifies whether diagonal moves are allowed\n */\nfunction Graph(gridIn, options) {\n  options = options || {};\n  this.nodes = [];\n  this.diagonal = !!options.diagonal;\n  this.grid = [];\n  for (var x = 0; x < gridIn.length; x++) {\n    this.grid[x] = [];\n\n    for (var y = 0, row = gridIn[x]; y < row.length; y++) {\n      var node = new GridNode(x, y, row[y]);\n      this.grid[x][y] = node;\n      this.nodes.push(node);\n    }\n  }\n  this.init();\n}\n\nGraph.prototype.init = function() {\n  this.dirtyNodes = [];\n  for (var i = 0; i < this.nodes.length; i++) {\n    astar.cleanNode(this.nodes[i]);\n  }\n};\n\nGraph.prototype.cleanDirty = function() {\n  for (var i = 0; i < this.dirtyNodes.length; i++) {\n    astar.cleanNode(this.dirtyNodes[i]);\n  }\n  this.dirtyNodes = [];\n};\n\nGraph.prototype.markDirty = function(node) {\n  this.dirtyNodes.push(node);\n};\n\nGraph.prototype.neighbors = function(node) {\n  var ret = [];\n  var x = node.x;\n  var y = node.y;\n  var grid = this.grid;\n\n  // West\n  if (grid[x - 1] && grid[x - 1][y]) {\n    ret.push(grid[x - 1][y]);\n  }\n\n  // East\n  if (grid[x + 1] && grid[x + 1][y]) {\n    ret.push(grid[x + 1][y]);\n  }\n\n  // South\n  if (grid[x] && grid[x][y - 1]) {\n    ret.push(grid[x][y - 1]);\n  }\n\n  // North\n  if (grid[x] && grid[x][y + 1]) {\n    ret.push(grid[x][y + 1]);\n  }\n\n  if (this.diagonal) {\n    // Southwest\n    if (grid[x - 1] && grid[x - 1][y - 1]) {\n      ret.push(grid[x - 1][y - 1]);\n    }\n\n    // Southeast\n    if (grid[x + 1] && grid[x + 1][y - 1]) {\n      ret.push(grid[x + 1][y - 1]);\n    }\n\n    // Northwest\n    if (grid[x - 1] && grid[x - 1][y + 1]) {\n      ret.push(grid[x - 1][y + 1]);\n    }\n\n    // Northeast\n    if (grid[x + 1] && grid[x + 1][y + 1]) {\n      ret.push(grid[x + 1][y + 1]);\n    }\n  }\n\n  return ret;\n};\n\nGraph.prototype.toString = function() {\n  var graphString = [];\n  var nodes = this.grid;\n  for (var x = 0; x < nodes.length; x++) {\n    var rowDebug = [];\n    var row = nodes[x];\n    for (var y = 0; y < row.length; y++) {\n      rowDebug.push(row[y].weight);\n    }\n    graphString.push(rowDebug.join(\" \"));\n  }\n  return graphString.join(\"\\n\");\n};\n\nfunction GridNode(x, y, weight) {\n  this.x = x;\n  this.y = y;\n  this.weight = weight;\n}\n\nGridNode.prototype.toString = function() {\n  return \"[\" + this.x + \" \" + this.y + \"]\";\n};\n\nGridNode.prototype.getCost = function(fromNeighbor) {\n  // Take diagonal weight into consideration.\n  if (fromNeighbor && fromNeighbor.x != this.x && fromNeighbor.y != this.y) {\n    return this.weight * 1.41421;\n  }\n  return this.weight;\n};\n\nGridNode.prototype.isWall = function() {\n  return this.weight === 0;\n};\n\nfunction BinaryHeap(scoreFunction) {\n  this.content = [];\n  this.scoreFunction = scoreFunction;\n}\n\nBinaryHeap.prototype = {\n  push: function(element) {\n    // Add the new element to the end of the array.\n    this.content.push(element);\n\n    // Allow it to sink down.\n    this.sinkDown(this.content.length - 1);\n  },\n  pop: function() {\n    // Store the first element so we can return it later.\n    var result = this.content[0];\n    // Get the element at the end of the array.\n    var end = this.content.pop();\n    // If there are any elements left, put the end element at the\n    // start, and let it bubble up.\n    if (this.content.length > 0) {\n      this.content[0] = end;\n      this.bubbleUp(0);\n    }\n    return result;\n  },\n  remove: function(node) {\n    var i = this.content.indexOf(node);\n\n    // When it is found, the process seen in 'pop' is repeated\n    // to fill up the hole.\n    var end = this.content.pop();\n\n    if (i !== this.content.length - 1) {\n      this.content[i] = end;\n\n      if (this.scoreFunction(end) < this.scoreFunction(node)) {\n        this.sinkDown(i);\n      } else {\n        this.bubbleUp(i);\n      }\n    }\n  },\n  size: function() {\n    return this.content.length;\n  },\n  rescoreElement: function(node) {\n    this.sinkDown(this.content.indexOf(node));\n  },\n  sinkDown: function(n) {\n    // Fetch the element that has to be sunk.\n    var element = this.content[n];\n\n    // When at 0, an element can not sink any further.\n    while (n > 0) {\n\n      // Compute the parent element's index, and fetch it.\n      var parentN = ((n + 1) >> 1) - 1;\n      var parent = this.content[parentN];\n      // Swap the elements if the parent is greater.\n      if (this.scoreFunction(element) < this.scoreFunction(parent)) {\n        this.content[parentN] = element;\n        this.content[n] = parent;\n        // Update 'n' to continue at the new position.\n        n = parentN;\n      }\n      // Found a parent that is less, no need to sink any further.\n      else {\n        break;\n      }\n    }\n  },\n  bubbleUp: function(n) {\n    // Look up the target element and its score.\n    var length = this.content.length;\n    var element = this.content[n];\n    var elemScore = this.scoreFunction(element);\n\n    while (true) {\n      // Compute the indices of the child elements.\n      var child2N = (n + 1) << 1;\n      var child1N = child2N - 1;\n      // This is used to store the new position of the element, if any.\n      var swap = null;\n      var child1Score;\n      // If the first child exists (is inside the array)...\n      if (child1N < length) {\n        // Look it up and compute its score.\n        var child1 = this.content[child1N];\n        child1Score = this.scoreFunction(child1);\n\n        // If the score is less than our element's, we need to swap.\n        if (child1Score < elemScore) {\n          swap = child1N;\n        }\n      }\n\n      // Do the same checks for the other child.\n      if (child2N < length) {\n        var child2 = this.content[child2N];\n        var child2Score = this.scoreFunction(child2);\n        if (child2Score < (swap === null ? elemScore : child1Score)) {\n          swap = child2N;\n        }\n      }\n\n      // If the element needs to be moved, swap it, and continue.\n      if (swap !== null) {\n        this.content[n] = this.content[swap];\n        this.content[swap] = element;\n        n = swap;\n      }\n      // Otherwise, we are done.\n      else {\n        break;\n      }\n    }\n  }\n};\n\nreturn {\n  astar: astar,\n  Graph: Graph\n};\n\n});","/**\r\n * Stripped down version of Phaser's Vector2 with just the functionality needed for navmeshes\r\n *\r\n * @export\r\n * @class Vector2\r\n */\r\nexport default class Vector2 {\r\n  constructor(x, y) {\r\n    this.x = x || 0;\r\n    this.y = y || 0;\r\n  }\r\n\r\n  equals(v) {\r\n    return this.x === v.x && this.y === v.y;\r\n  }\r\n\r\n  angle(v) {\r\n    return Math.atan2(v.y - this.y, v.x - this.x);\r\n  }\r\n\r\n  distance(v) {\r\n    const dx = v.x - this.x;\r\n    const dy = v.y - this.y;\r\n    return Math.sqrt(dx * dx + dy * dy);\r\n  }\r\n\r\n  add(v) {\r\n    this.x += v.x;\r\n    this.y += v.y;\r\n  }\r\n\r\n  subtract(v) {\r\n    this.x -= v.x;\r\n    this.y -= v.y;\r\n  }\r\n\r\n  clone() {\r\n    return new Vector2(this.x, this.y);\r\n  }\r\n}\r\n","import Vector2 from \"./math/vector-2\";\r\n\r\n/**\r\n * A class that represents a navigable polygon with a navmesh. It is built on top of a\r\n * {@link Polygon}. It implements the properties and fields that javascript-astar needs - weight,\r\n * toString, isWall and getCost. See GPS test from astar repo for structure:\r\n * https://github.com/bgrins/javascript-astar/blob/master/test/tests.js\r\n *\r\n * @class NavPoly\r\n */\r\nexport default class NavPoly {\r\n  /**\r\n   * Creates an instance of NavPoly.\r\n   * @param {number} id\r\n   * @param {Polygon} polygon\r\n   *\r\n   * @memberof NavPoly\r\n   */\r\n  constructor(id, polygon) {\r\n    this.id = id;\r\n    this.polygon = polygon;\r\n    this.edges = polygon.edges;\r\n    this.neighbors = [];\r\n    this.portals = [];\r\n    this.centroid = this.calculateCentroid();\r\n    this.boundingRadius = this.calculateRadius();\r\n\r\n    this.weight = 1; // jsastar property\r\n  }\r\n\r\n  /**\r\n   * Returns an array of points that form the polygon.\r\n   *\r\n   * @returns {Vector2[]}\r\n   * @memberof NavPoly\r\n   */\r\n  getPoints() {\r\n    return this.polygon.points;\r\n  }\r\n\r\n  /**\r\n   * Check if the given point-like object is within the polygon\r\n   *\r\n   * @param {object} point Object of the form {x, y}\r\n   * @returns {boolean}\r\n   * @memberof NavPoly\r\n   */\r\n  contains(point) {\r\n    // Phaser's polygon check doesn't handle when a point is on one of the edges of the line. Note:\r\n    // check numerical stability here. It would also be good to optimize this for different shapes.\r\n    return this.polygon.contains(point.x, point.y) || this.isPointOnEdge(point);\r\n  }\r\n\r\n  /**\r\n   * Only rectangles are supported, so this calculation works, but this is not actually the centroid\r\n   * calculation for a polygon. This is just the average of the vertices - proper centroid of a\r\n   * polygon factors in the area.\r\n   *\r\n   * @returns {Vector2}\r\n   * @memberof NavPoly\r\n   */\r\n  calculateCentroid() {\r\n    const centroid = new Vector2(0, 0);\r\n    const length = this.polygon.points.length;\r\n    this.polygon.points.forEach(p => centroid.add(p));\r\n    centroid.x /= length;\r\n    centroid.y /= length;\r\n    return centroid;\r\n  }\r\n\r\n  /**\r\n   * Calculate the radius of a circle that circumscribes the polygon.\r\n   *\r\n   * @returns {number}\r\n   * @memberof NavPoly\r\n   */\r\n  calculateRadius() {\r\n    let boundingRadius = 0;\r\n    for (const point of this.polygon.points) {\r\n      const d = this.centroid.distance(point);\r\n      if (d > boundingRadius) boundingRadius = d;\r\n    }\r\n    return boundingRadius;\r\n  }\r\n\r\n  /**\r\n   * Check if the given point-like object is on one of the edges of the polygon.\r\n   *\r\n   * @param {object} Point-like object in the form { x, y }\r\n   * @returns {boolean}\r\n   * @memberof NavPoly\r\n   */\r\n  isPointOnEdge({ x, y }) {\r\n    for (const edge of this.edges) {\r\n      if (edge.pointOnSegment(x, y)) return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  destroy() {\r\n    this.neighbors = [];\r\n    this.portals = [];\r\n  }\r\n\r\n  // jsastar methods\r\n  toString() {\r\n    return `NavPoly(id: ${this.id} at: ${this.centroid})`;\r\n  }\r\n  isWall() {\r\n    return this.weight === 0;\r\n  }\r\n  centroidDistance(navPolygon) {\r\n    return this.centroid.distance(navPolygon.centroid);\r\n  }\r\n  getCost(navPolygon) {\r\n    return this.centroidDistance(navPolygon);\r\n  }\r\n}\r\n","import jsastar from \"javascript-astar\";\r\n\r\n/**\r\n * Graph for javascript-astar. It implements the functionality for astar. See GPS test from astar\r\n * repo for structure: https://github.com/bgrins/javascript-astar/blob/master/test/tests.js\r\n *\r\n * @class NavGraph\r\n * @private\r\n */\r\nclass NavGraph {\r\n  constructor(navPolygons) {\r\n    this.nodes = navPolygons;\r\n    this.init();\r\n  }\r\n\r\n  neighbors(navPolygon) {\r\n    return navPolygon.neighbors;\r\n  }\r\n\r\n  navHeuristic(navPolygon1, navPolygon2) {\r\n    return navPolygon1.centroidDistance(navPolygon2);\r\n  }\r\n\r\n  destroy() {\r\n    this.cleanDirty();\r\n    this.nodes = [];\r\n  }\r\n}\r\n\r\nNavGraph.prototype.init = jsastar.Graph.prototype.init;\r\nNavGraph.prototype.cleanDirty = jsastar.Graph.prototype.cleanDirty;\r\nNavGraph.prototype.markDirty = jsastar.Graph.prototype.markDirty;\r\n\r\nexport default NavGraph;\r\n","/**\r\n * Twice the area of the triangle formed by a, b and c\r\n * @returns {number}\r\n * @private\r\n */\r\nexport function triarea2(a, b, c) {\r\n  const ax = b.x - a.x;\r\n  const ay = b.y - a.y;\r\n  const bx = c.x - a.x;\r\n  const by = c.y - a.y;\r\n  return bx * ay - ax * by;\r\n}\r\n\r\n/**\r\n * Clamp value between min and max\r\n * @returns {number}\r\n * @private\r\n */\r\nexport function clamp(value, min, max) {\r\n  if (value < min) value = min;\r\n  if (value > max) value = max;\r\n  return value;\r\n}\r\n\r\n/**\r\n * Check if two values within a small margin of one another\r\n * @returns {boolean}\r\n * @private\r\n */\r\nexport function almostEqual(value1, value2, errorMargin = 0.0001) {\r\n  if (Math.abs(value1 - value2) <= errorMargin) return true;\r\n  else return false;\r\n}\r\n\r\n/**\r\n * Find the smallest angle difference between two angles\r\n * https://gist.github.com/Aaronduino/4068b058f8dbc34b4d3a9eedc8b2cbe0\r\n * @returns {number}\r\n * @private\r\n */\r\nexport function angleDifference(x, y) {\r\n  let a = x - y;\r\n  const i = a + Math.PI;\r\n  const j = Math.PI * 2;\r\n  a = i - Math.floor(i / j) * j; // (a+180) % 360; this ensures the correct sign\r\n  a -= Math.PI;\r\n  return a;\r\n}\r\n\r\n/**\r\n * Check if two lines are collinear (within a marign)\r\n * @returns {boolean}\r\n * @private\r\n */\r\nexport function areCollinear(line1, line2, errorMargin = 0.0001) {\r\n  // Figure out if the two lines are equal by looking at the area of the triangle formed\r\n  // by their points\r\n  const area1 = triarea2(line1.start, line1.end, line2.start);\r\n  const area2 = triarea2(line1.start, line1.end, line2.end);\r\n  if (almostEqual(area1, 0, errorMargin) && almostEqual(area2, 0, errorMargin)) {\r\n    return true;\r\n  } else return false;\r\n}\r\n","// Mostly sourced from PatrolJS at the moment. TODO: come back and reimplement this as an incomplete\r\n// funnel algorithm so astar checks can be more accurate.\r\n\r\nimport { triarea2 } from \"./utils\";\r\n\r\n/**\r\n * @private\r\n */\r\nclass Channel {\r\n  constructor() {\r\n    this.portals = [];\r\n  }\r\n\r\n  push(p1, p2 = null) {\r\n    if (p2 === null) p2 = p1;\r\n    this.portals.push({\r\n      left: p1,\r\n      right: p2\r\n    });\r\n  }\r\n\r\n  stringPull() {\r\n    var portals = this.portals;\r\n    var pts = [];\r\n    // Init scan state\r\n    var portalApex, portalLeft, portalRight;\r\n    var apexIndex = 0,\r\n      leftIndex = 0,\r\n      rightIndex = 0;\r\n\r\n    portalApex = portals[0].left;\r\n    portalLeft = portals[0].left;\r\n    portalRight = portals[0].right;\r\n\r\n    // Add start point.\r\n    pts.push(portalApex);\r\n\r\n    for (var i = 1; i < portals.length; i++) {\r\n      // Find the next portal vertices\r\n      var left = portals[i].left;\r\n      var right = portals[i].right;\r\n\r\n      // Update right vertex.\r\n      if (triarea2(portalApex, portalRight, right) <= 0.0) {\r\n        if (portalApex.equals(portalRight) || triarea2(portalApex, portalLeft, right) > 0.0) {\r\n          // Tighten the funnel.\r\n          portalRight = right;\r\n          rightIndex = i;\r\n        } else {\r\n          // Right vertex just crossed over the left vertex, so the left vertex should\r\n          // now be part of the path.\r\n          pts.push(portalLeft);\r\n\r\n          // Restart scan from portal left point.\r\n\r\n          // Make current left the new apex.\r\n          portalApex = portalLeft;\r\n          apexIndex = leftIndex;\r\n          // Reset portal\r\n          portalLeft = portalApex;\r\n          portalRight = portalApex;\r\n          leftIndex = apexIndex;\r\n          rightIndex = apexIndex;\r\n          // Restart scan\r\n          i = apexIndex;\r\n          continue;\r\n        }\r\n      }\r\n\r\n      // Update left vertex.\r\n      if (triarea2(portalApex, portalLeft, left) >= 0.0) {\r\n        if (portalApex.equals(portalLeft) || triarea2(portalApex, portalRight, left) < 0.0) {\r\n          // Tighten the funnel.\r\n          portalLeft = left;\r\n          leftIndex = i;\r\n        } else {\r\n          // Left vertex just crossed over the right vertex, so the right vertex should\r\n          // now be part of the path\r\n          pts.push(portalRight);\r\n\r\n          // Restart scan from portal right point.\r\n\r\n          // Make current right the new apex.\r\n          portalApex = portalRight;\r\n          apexIndex = rightIndex;\r\n          // Reset portal\r\n          portalLeft = portalApex;\r\n          portalRight = portalApex;\r\n          leftIndex = apexIndex;\r\n          rightIndex = apexIndex;\r\n          // Restart scan\r\n          i = apexIndex;\r\n          continue;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (pts.length === 0 || !pts[pts.length - 1].equals(portals[portals.length - 1].left)) {\r\n      // Append last point to path.\r\n      pts.push(portals[portals.length - 1].left);\r\n    }\r\n\r\n    this.path = pts;\r\n    return pts;\r\n  }\r\n}\r\n\r\nexport default Channel;\r\n","import Vector2 from \"./vector-2\";\r\n\r\n/**\r\n * Stripped down version of Phaser's Line with just the functionality needed for navmeshes\r\n *\r\n * @export\r\n * @class Line\r\n */\r\nexport default class Line {\r\n  constructor(x1, y1, x2, y2) {\r\n    this.start = new Vector2(x1, y1);\r\n    this.end = new Vector2(x2, y2);\r\n\r\n    this.left = Math.min(x1, x2);\r\n    this.right = Math.max(x1, x2);\r\n    this.top = Math.min(y1, y2);\r\n    this.bottom = Math.max(y1, y2);\r\n  }\r\n\r\n  pointOnSegment(x, y) {\r\n    return (\r\n      x >= this.left &&\r\n      x <= this.right &&\r\n      y >= this.top &&\r\n      y <= this.bottom &&\r\n      this.pointOnLine(x, y)\r\n    );\r\n  }\r\n\r\n  pointOnLine(x, y) {\r\n    // Compare slope of line start -> xy to line start -> line end\r\n    return (x - this.left) * (this.bottom - this.top) === (this.right - this.left) * (y - this.top);\r\n  }\r\n}\r\n","import Line from \"./line\";\r\n\r\n/**\r\n * Stripped down version of Phaser's Polygon with just the functionality needed for navmeshes\r\n *\r\n * @export\r\n * @class Polygon\r\n */\r\nexport default class Polygon {\r\n  constructor(points, closed = true) {\r\n    this.points = points;\r\n    this.edges = [];\r\n\r\n    for (let i = 1; i < points.length; i++) {\r\n      const p1 = points[i - 1];\r\n      const p2 = points[i];\r\n      this.edges.push(new Line(p1.x, p1.y, p2.x, p2.y));\r\n    }\r\n    if (closed) {\r\n      const first = points[0];\r\n      const last = points[points.length - 1];\r\n      this.edges.push(new Line(first.x, first.y, last.x, last.y));\r\n    }\r\n  }\r\n\r\n  contains(x, y) {\r\n    let inside = false;\r\n\r\n    for (let i = -1, j = this.points.length - 1; ++i < this.points.length; j = i) {\r\n      const ix = this.points[i].x;\r\n      const iy = this.points[i].y;\r\n\r\n      const jx = this.points[j].x;\r\n      const jy = this.points[j].y;\r\n\r\n      if (\r\n        ((iy <= y && y < jy) || (jy <= y && y < iy)) &&\r\n        x < ((jx - ix) * (y - iy)) / (jy - iy) + ix\r\n      ) {\r\n        inside = !inside;\r\n      }\r\n    }\r\n\r\n    return inside;\r\n  }\r\n}\r\n","import jsastar from \"javascript-astar\";\r\nimport NavPoly from \"./navpoly\";\r\nimport NavGraph from \"./navgraph\";\r\nimport Channel from \"./channel\";\r\nimport { angleDifference, areCollinear, clamp } from \"./utils\";\r\nimport Vector2 from \"./math/vector-2\";\r\nimport Line from \"./math/line\";\r\nimport Polygon from \"./math/polygon\";\r\n\r\n/**\r\n * The workhorse that represents a navigation mesh built from a series of polygons. Once built, the\r\n * mesh can be asked for a path from one point to another point. Some internal terminology usage:\r\n * - neighbor: a polygon that shares part of an edge with another polygon\r\n * - portal: when two neighbor's have edges that overlap, the portal is the overlapping line segment\r\n * - channel: the path of polygons from starting point to end point\r\n * - pull the string: run the funnel algorithm on the channel so that the path hugs the edges of the\r\n *   channel. Equivalent to having a string snaking through a hallway and then pulling it taut.\r\n *\r\n * @class NavMesh\r\n */\r\nexport default class NavMesh {\r\n  /**\r\n   * Creates an instance of NavMesh.\r\n   * @param {object[][]} meshPolygonPoints Array where each element is an array of point-like\r\n   * objects that defines a polygon.\r\n   * @param {number} [meshShrinkAmount=0] The amount (in pixels) that the navmesh has been\r\n   * shrunk around obstacles (a.k.a the amount obstacles have been expanded)\r\n   * @memberof NavMesh\r\n   */\r\n  constructor(meshPolygonPoints, meshShrinkAmount = 0) {\r\n    this._meshShrinkAmount = meshShrinkAmount;\r\n\r\n    const newPolys = meshPolygonPoints.map(polyPoints => {\r\n      const vectors = polyPoints.map(p => new Vector2(p.x, p.y));\r\n      return new Polygon(vectors);\r\n    });\r\n\r\n    this._navPolygons = newPolys.map((polygon, i) => new NavPoly(i, polygon));\r\n\r\n    this._calculateNeighbors();\r\n\r\n    // Astar graph of connections between polygons\r\n    this._graph = new NavGraph(this._navPolygons);\r\n  }\r\n\r\n  /**\r\n   * Get the NavPolys that are in this navmesh.\r\n   *\r\n   * @returns {NavPoly[]}\r\n   * @memberof NavMesh\r\n   */\r\n  getPolygons() {\r\n    return this._navPolygons;\r\n  }\r\n\r\n  /**\r\n   * Cleanup method to remove references.\r\n   *\r\n   * @memberof NavMesh\r\n   */\r\n  destroy() {\r\n    this._graph.destroy();\r\n    for (const poly of this._navPolygons) poly.destroy();\r\n    this._navPolygons = [];\r\n  }\r\n\r\n  /**\r\n   * Find a path from the start point to the end point using this nav mesh.\r\n   *\r\n   * @param {object} startPoint A point-like object in the form {x, y}\r\n   * @param {object} endPoint A point-like object in the form {x, y}\r\n   * @returns {Vector2[]|null} An array of points if a path is found, or null if no path\r\n   *\r\n   * @memberof NavMesh\r\n   */\r\n  findPath(startPoint, endPoint) {\r\n    let startPoly = null;\r\n    let endPoly = null;\r\n    let startDistance = Number.MAX_VALUE;\r\n    let endDistance = Number.MAX_VALUE;\r\n    let d, r;\r\n    const startVector = new Vector2(startPoint.x, startPoint.y);\r\n    const endVector = new Vector2(endPoint.x, endPoint.y);\r\n\r\n    // Find the closest poly for the starting and ending point\r\n    for (const navPoly of this._navPolygons) {\r\n      r = navPoly.boundingRadius;\r\n      // Start\r\n      d = navPoly.centroid.distance(startVector);\r\n      if (d <= startDistance && d <= r && navPoly.contains(startVector)) {\r\n        startPoly = navPoly;\r\n        startDistance = d;\r\n      }\r\n      // End\r\n      d = navPoly.centroid.distance(endVector);\r\n      if (d <= endDistance && d <= r && navPoly.contains(endVector)) {\r\n        endPoly = navPoly;\r\n        endDistance = d;\r\n      }\r\n    }\r\n\r\n    // If the start point wasn't inside a polygon, run a more liberal check that allows a point\r\n    // to be within meshShrinkAmount radius of a polygon\r\n    if (!startPoly && this._meshShrinkAmount > 0) {\r\n      for (const navPoly of this._navPolygons) {\r\n        // Check if point is within bounding circle to avoid extra projection calculations\r\n        r = navPoly.boundingRadius + this._meshShrinkAmount;\r\n        d = navPoly.centroid.distance(startVector);\r\n        if (d <= r) {\r\n          // Check if projected point is within range of a polgyon and is closer than the\r\n          // previous point\r\n          const { distance } = this._projectPointToPolygon(startVector, navPoly);\r\n          if (distance <= this._meshShrinkAmount && distance < startDistance) {\r\n            startPoly = navPoly;\r\n            startDistance = distance;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Same check as above, but for the end point\r\n    if (!endPoly && this._meshShrinkAmount > 0) {\r\n      for (const navPoly of this._navPolygons) {\r\n        r = navPoly.boundingRadius + this._meshShrinkAmount;\r\n        d = navPoly.centroid.distance(endVector);\r\n        if (d <= r) {\r\n          const { distance } = this._projectPointToPolygon(endVector, navPoly);\r\n          if (distance <= this._meshShrinkAmount && distance < endDistance) {\r\n            endPoly = navPoly;\r\n            endDistance = distance;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // No matching polygons locations for the start or end, so no path found\r\n    if (!startPoly || !endPoly) return null;\r\n\r\n    // If the start and end polygons are the same, return a direct path\r\n    if (startPoly === endPoly) return [startVector, endVector];\r\n\r\n    // Search!\r\n    const astarPath = jsastar.astar.search(this._graph, startPoly, endPoly, {\r\n      heuristic: this._graph.navHeuristic\r\n    });\r\n\r\n    // While the start and end polygons may be valid, no path between them\r\n    if (astarPath.length === 0) return null;\r\n\r\n    // jsastar drops the first point from the path, but the funnel algorithm needs it\r\n    astarPath.unshift(startPoly);\r\n\r\n    // We have a path, so now time for the funnel algorithm\r\n    const channel = new Channel();\r\n    channel.push(startVector);\r\n    for (let i = 0; i < astarPath.length - 1; i++) {\r\n      const navPolygon = astarPath[i];\r\n      const nextNavPolygon = astarPath[i + 1];\r\n\r\n      // Find the portal\r\n      let portal = null;\r\n      for (let i = 0; i < navPolygon.neighbors.length; i++) {\r\n        if (navPolygon.neighbors[i].id === nextNavPolygon.id) {\r\n          portal = navPolygon.portals[i];\r\n        }\r\n      }\r\n\r\n      // Push the portal vertices into the channel\r\n      channel.push(portal.start, portal.end);\r\n    }\r\n    channel.push(endVector);\r\n\r\n    // Pull a string along the channel to run the funnel\r\n    channel.stringPull();\r\n\r\n    // Clone path, excluding duplicates\r\n    let lastPoint = null;\r\n    const phaserPath = [];\r\n    for (const p of channel.path) {\r\n      const newPoint = p.clone();\r\n      if (!lastPoint || !newPoint.equals(lastPoint)) phaserPath.push(newPoint);\r\n      lastPoint = newPoint;\r\n    }\r\n\r\n    return phaserPath;\r\n  }\r\n\r\n  _calculateNeighbors() {\r\n    // Fill out the neighbor information for each navpoly\r\n    for (let i = 0; i < this._navPolygons.length; i++) {\r\n      const navPoly = this._navPolygons[i];\r\n\r\n      for (let j = i + 1; j < this._navPolygons.length; j++) {\r\n        const otherNavPoly = this._navPolygons[j];\r\n\r\n        // Check if the other navpoly is within range to touch\r\n        const d = navPoly.centroid.distance(otherNavPoly.centroid);\r\n        if (d > navPoly.boundingRadius + otherNavPoly.boundingRadius) continue;\r\n\r\n        // The are in range, so check each edge pairing\r\n        for (const edge of navPoly.edges) {\r\n          for (const otherEdge of otherNavPoly.edges) {\r\n            // If edges aren't collinear, not an option for connecting navpolys\r\n            if (!areCollinear(edge, otherEdge)) continue;\r\n\r\n            // If they are collinear, check if they overlap\r\n            const overlap = this._getSegmentOverlap(edge, otherEdge);\r\n            if (!overlap) continue;\r\n\r\n            // Connections are symmetric!\r\n            navPoly.neighbors.push(otherNavPoly);\r\n            otherNavPoly.neighbors.push(navPoly);\r\n\r\n            // Calculate the portal between the two polygons - this needs to be in\r\n            // counter-clockwise order, relative to each polygon\r\n            const [p1, p2] = overlap;\r\n            let edgeStartAngle = navPoly.centroid.angle(edge.start);\r\n            let a1 = navPoly.centroid.angle(overlap[0]);\r\n            let a2 = navPoly.centroid.angle(overlap[1]);\r\n            let d1 = angleDifference(edgeStartAngle, a1);\r\n            let d2 = angleDifference(edgeStartAngle, a2);\r\n            if (d1 < d2) {\r\n              navPoly.portals.push(new Line(p1.x, p1.y, p2.x, p2.y));\r\n            } else {\r\n              navPoly.portals.push(new Line(p2.x, p2.y, p1.x, p1.y));\r\n            }\r\n\r\n            edgeStartAngle = otherNavPoly.centroid.angle(otherEdge.start);\r\n            a1 = otherNavPoly.centroid.angle(overlap[0]);\r\n            a2 = otherNavPoly.centroid.angle(overlap[1]);\r\n            d1 = angleDifference(edgeStartAngle, a1);\r\n            d2 = angleDifference(edgeStartAngle, a2);\r\n            if (d1 < d2) {\r\n              otherNavPoly.portals.push(new Line(p1.x, p1.y, p2.x, p2.y));\r\n            } else {\r\n              otherNavPoly.portals.push(new Line(p2.x, p2.y, p1.x, p1.y));\r\n            }\r\n\r\n            // Two convex polygons shouldn't be connected more than once! (Unless\r\n            // there are unnecessary vertices...)\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Check two collinear line segments to see if they overlap by sorting the points.\r\n  // Algorithm source: http://stackoverflow.com/a/17152247\r\n  _getSegmentOverlap(line1, line2) {\r\n    const points = [\r\n      { line: line1, point: line1.start },\r\n      { line: line1, point: line1.end },\r\n      { line: line2, point: line2.start },\r\n      { line: line2, point: line2.end }\r\n    ];\r\n    points.sort(function(a, b) {\r\n      if (a.point.x < b.point.x) return -1;\r\n      else if (a.point.x > b.point.x) return 1;\r\n      else {\r\n        if (a.point.y < b.point.y) return -1;\r\n        else if (a.point.y > b.point.y) return 1;\r\n        else return 0;\r\n      }\r\n    });\r\n    // If the first two points in the array come from the same line, no overlap\r\n    const noOverlap = points[0].line === points[1].line;\r\n    // If the two middle points in the array are the same coordinates, then there is a\r\n    // single point of overlap.\r\n    const singlePointOverlap = points[1].point.equals(points[2].point);\r\n    if (noOverlap || singlePointOverlap) return null;\r\n    else return [points[1].point, points[2].point];\r\n  }\r\n\r\n  /**\r\n   * Project a point onto a polygon in the shortest distance possible.\r\n   *\r\n   * @param {Phaser.Point} point The point to project\r\n   * @param {NavPoly} navPoly The navigation polygon to test against\r\n   * @returns {{point: Phaser.Point, distance: number}}\r\n   *\r\n   * @private\r\n   * @memberof NavMesh\r\n   */\r\n  _projectPointToPolygon(point, navPoly) {\r\n    let closestProjection = null;\r\n    let closestDistance = Number.MAX_VALUE;\r\n    for (const edge of navPoly.edges) {\r\n      const projectedPoint = this._projectPointToEdge(point, edge);\r\n      const d = point.distance(projectedPoint);\r\n      if (closestProjection === null || d < closestDistance) {\r\n        closestDistance = d;\r\n        closestProjection = projectedPoint;\r\n      }\r\n    }\r\n    return { point: closestProjection, distance: closestDistance };\r\n  }\r\n\r\n  _distanceSquared(a, b) {\r\n    const dx = b.x - a.x;\r\n    const dy = b.y - a.y;\r\n    return dx * dx + dy * dy;\r\n  }\r\n\r\n  // Project a point onto a line segment\r\n  // JS Source: http://stackoverflow.com/questions/849211/shortest-distance-between-a-point-and-a-line-segment\r\n  _projectPointToEdge(point, line) {\r\n    const a = line.start;\r\n    const b = line.end;\r\n    // Consider the parametric equation for the edge's line, p = a + t (b - a). We want to find\r\n    // where our point lies on the line by solving for t:\r\n    //  t = [(p-a) . (b-a)] / |b-a|^2\r\n    const l2 = this._distanceSquared(a, b);\r\n    let t = ((point.x - a.x) * (b.x - a.x) + (point.y - a.y) * (b.y - a.y)) / l2;\r\n    // We clamp t from [0,1] to handle points outside the segment vw.\r\n    t = clamp(t, 0, 1);\r\n    // Project onto the segment\r\n    const p = new Vector2(a.x + t * (b.x - a.x), a.y + t * (b.y - a.y));\r\n    return p;\r\n  }\r\n}\r\n","import NavMesh from \"./navmesh\";\r\n\r\nexport default NavMesh;\r\n","import NavMesh from \"navmesh/src\"; // import the source - not the dist - no need to double build\r\n\r\n/**\r\n * A wrapper around {@link NavMesh} for Phaser 2 / Phaser CE. Create instances of this class from\r\n * {@link Phaser2NavMeshPlugin}. This is the workhorse that represents a navigation mesh built from\r\n * a series of polygons. Once built, the mesh can be asked for a path from one point to another\r\n * point.\r\n *\r\n * Compared to {@link NavMesh}, this adds visual debugging capabilities and converts paths to\r\n * Phaser-compatible point instances.\r\n *\r\n * @export\r\n * @class Phaser2NavMesh\r\n */\r\nexport default class Phaser2NavMesh {\r\n  /**\r\n   * Creates an instance of Phaser2NavMesh.\r\n   * @param {Phaser2NavMeshPlugin} plugin The plugin that owns this mesh.\r\n   * @param {string} key The key the mesh is stored under within the plugin.\r\n   * @param {object[][]} meshPolygonPoints Array where each element is an array of point-like\r\n   * objects that defines a polygon.\r\n   * @param {number} [meshShrinkAmount=0] The amount (in pixels) that the navmesh has been shrunk\r\n   * around obstacles (a.k.a the amount obstacles have been expanded)\r\n   * @memberof Phaser2NavMesh\r\n   */\r\n  constructor(plugin, key, meshPolygonPoints, meshShrinkAmount = 0) {\r\n    this.key = key;\r\n    this.plugin = plugin;\r\n    this.game = plugin.game;\r\n    this.debugGraphics = null;\r\n    this.navMesh = new NavMesh(meshPolygonPoints, meshShrinkAmount);\r\n  }\r\n\r\n  /**\r\n   * See {@link NavMesh#findPath}. This implements the same functionality, except that the returned\r\n   * path is converted to Phaser-compatible points.\r\n   *\r\n   * @param {object} startPoint A point-like object in the form {x, y}\r\n   * @param {object} endPoint A point-like object in the form {x, y}\r\n   * @param {class} [PointClass=Phaser.Geom.Point]\r\n   * @returns {object[]|null} An array of points if a path is found, or null if no path\r\n   * @memberof Phaser2NavMesh\r\n   */\r\n  findPath(startPoint, endPoint, PointClass = Phaser.Point) {\r\n    const path = this.navMesh.findPath(startPoint, endPoint);\r\n    return path ? path.map(({ x, y }) => new PointClass(x, y)) : path;\r\n  }\r\n\r\n  /**\r\n   * Enable the debug drawing graphics. If no graphics object is providied, a new instance will be\r\n   * created.\r\n   *\r\n   * @param {Phaser.Graphics} [graphics] An optional graphics object for the mesh to use\r\n   * for debug drawing. Note, the mesh will destroy this graphics object when the mesh is destroyed.\r\n   * @returns {Phaser.Graphics} The graphics object this mesh uses.\r\n   * @memberof Phaser2NavMesh\r\n   */\r\n  enableDebug(graphics) {\r\n    if (!graphics && !this.debugGraphics) {\r\n      this.debugGraphics = this.game.add.graphics();\r\n    } else if (graphics) {\r\n      if (this.debugGraphics) this.debugGraphics.destroy();\r\n      this.debugGraphics = graphics;\r\n    }\r\n\r\n    this.debugGraphics.visible = true;\r\n\r\n    return this.debugGraphics;\r\n  }\r\n\r\n  /**\r\n   * Hide the debug graphics, but don't destroy it.\r\n   *\r\n   * @memberof Phaser2NavMesh\r\n   */\r\n  disableDebug() {\r\n    if (this.debugGraphics) this.debugGraphics.visible = false;\r\n  }\r\n\r\n  /**\r\n   * Returns true if the debug graphics object is enabled and visible.\r\n   *\r\n   * @returns {boolean}\r\n   * @memberof Phaser2NavMesh\r\n   */\r\n  isDebugEnabled() {\r\n    return this.debugGraphics && this.debugGraphics.visible;\r\n  }\r\n\r\n  /**\r\n   * Clear the debug graphics.\r\n   *\r\n   * @memberof Phaser2NavMesh\r\n   */\r\n  debugDrawClear() {\r\n    if (this.debugGraphics) this.debugGraphics.clear();\r\n  }\r\n\r\n  /**\r\n   * Visualize the polygons in the navmesh by drawing them to the debug graphics.\r\n   *\r\n   * @param {object} options\r\n   * @param {boolean} [options.drawCentroid=true] For each polygon, show the approx centroid\r\n   * @param {boolean} [options.drawBounds=false] For each polygon, show the bounding radius\r\n   * @param {boolean} [options.drawNeighbors=true] For each polygon, show the connections to\r\n   * neighbors\r\n   * @param {boolean} [options.drawPortals=true] For each polygon, show the portal edges\r\n   * @param {number[]} [options.palette=[0x00a0b0, 0x6a4a3c, 0xcc333f, 0xeb6841, 0xedc951]] An array\r\n   * of Phaser-compatible format colors to use when drawing the individual polygons. The first poly\r\n   * uses the first color, the second poly uses the second color, etc.\r\n   * @memberof Phaser2NavMesh\r\n   */\r\n  debugDrawMesh({\r\n    drawCentroid = true,\r\n    drawBounds = false,\r\n    drawNeighbors = true,\r\n    drawPortals = true,\r\n    palette = [0x00a0b0, 0x6a4a3c, 0xcc333f, 0xeb6841, 0xedc951]\r\n  } = {}) {\r\n    if (!this.debugGraphics) return;\r\n\r\n    const navPolys = this.navMesh.getPolygons();\r\n\r\n    navPolys.forEach(poly => {\r\n      const color = palette[poly.id % palette.length];\r\n      this.debugGraphics.lineWidth = 0;\r\n      this.debugGraphics.beginFill(color);\r\n      this.debugGraphics.drawPolygon(new Phaser.Polygon(...poly.getPoints()));\r\n      this.debugGraphics.endFill();\r\n\r\n      if (drawCentroid) {\r\n        this.debugGraphics.beginFill(0x000000);\r\n        this.debugGraphics.drawEllipse(poly.centroid.x, poly.centroid.y, 4, 4);\r\n        this.debugGraphics.endFill();\r\n      }\r\n\r\n      if (drawBounds) {\r\n        this.debugGraphics.lineStyle(1, 0xffffff);\r\n        const r = poly.boundingRadius;\r\n        this.debugGraphics.drawEllipse(poly.centroid.x, poly.centroid.y, r, r);\r\n      }\r\n\r\n      if (drawNeighbors) {\r\n        this.debugGraphics.lineStyle(2, 0x000000);\r\n        poly.neighbors.forEach(n => {\r\n          this.debugGraphics.moveTo(poly.centroid.x, poly.centroid.y);\r\n          this.debugGraphics.lineTo(n.centroid.x, n.centroid.y);\r\n        });\r\n      }\r\n\r\n      if (drawPortals) {\r\n        this.debugGraphics.lineStyle(10, 0x000000);\r\n        poly.portals.forEach(portal => {\r\n          this.debugGraphics.moveTo(portal.start.x, portal.start.y);\r\n          this.debugGraphics.lineTo(portal.end.x, portal.end.y);\r\n        });\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Visualize a path (array of points) on the debug graphics.\r\n   *\r\n   * @param {object[]} path Array of point-like objects in the form {x, y}\r\n   * @param {number} [color=0x00FF00]\r\n   * @param {number} [thickness=10]\r\n   * @param {number} [alpha=1]\r\n   * @memberof Phaser2NavMesh\r\n   */\r\n  debugDrawPath(path, color = 0x00ff00, thickness = 10, alpha = 1) {\r\n    if (!this.debugGraphics) return;\r\n\r\n    if (path && path.length) {\r\n      // Draw line for path\r\n      this.debugGraphics.lineStyle(thickness, color, alpha);\r\n      this.debugGraphics.drawShape(new Phaser.Polygon(...path));\r\n\r\n      // Draw circle at start and end of path\r\n      this.debugGraphics.beginFill(color, alpha);\r\n      const d = 0.5 * thickness;\r\n      this.debugGraphics.drawEllipse(path[0].x, path[0].y, d, d);\r\n      if (path.length > 1) {\r\n        const lastPoint = path[path.length - 1];\r\n        this.debugGraphics.drawEllipse(lastPoint.x, lastPoint.y, d, d);\r\n      }\r\n      this.debugGraphics.endFill();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Destroy the mesh, kill the debug graphic and unregister itself with the plugin.\r\n   *\r\n   * @memberof Phaser2NavMesh\r\n   */\r\n  destroy() {\r\n    if (this.navMesh) this.navMesh.destroy();\r\n    if (this.debugGraphics) this.debugGraphics.destroy();\r\n    this.plugin.removeMesh(this.key);\r\n    this.navMesh = undefined;\r\n    this.debugGraphics = undefined;\r\n    this.plugin = undefined;\r\n    this.scene = undefined;\r\n  }\r\n}\r\n","import Phaser2NavMesh from \"./phaser2-navmesh\";\r\n\r\n/**\r\n * This class can create navigation meshes for use in Phaser 2 / Phaser CE. (For Phaser 3, see\r\n * {@link PhaserNavMeshPlugin}.) The navmeshes can be constructed from convex polygons embedded in a\r\n * Tiled map. The class that conforms to Phaser 2's plugin structure.\r\n *\r\n * @export\r\n * @class Phaser2NavMeshPlugin\r\n */\r\nexport default class Phaser2NavMeshPlugin extends Phaser.Plugin {\r\n  constructor(game, pluginManager) {\r\n    super(game, pluginManager);\r\n\r\n    this.phaserNavMeshes = {};\r\n  }\r\n\r\n  /**\r\n   * Destroy all navmeshes created and the plugin itself\r\n   *\r\n   * @memberof Phaser2NavMeshPlugin\r\n   */\r\n  destroy() {\r\n    const meshes = Object.values(this.phaserNavMeshes);\r\n    this.phaserNavMeshes = {};\r\n    meshes.forEach(m => m.destroy());\r\n    this.game = undefined;\r\n  }\r\n\r\n  /**\r\n   * Remove the navmesh stored under the given key from the plugin. This does not destroy the\r\n   * navmesh.\r\n   *\r\n   * @param {string} key\r\n   * @memberof Phaser2NavMeshPlugin\r\n   */\r\n  removeMesh(key) {\r\n    if (this.phaserNavMeshes[key]) this.phaserNavMeshes[key] = undefined;\r\n  }\r\n\r\n  /**\r\n   * Load a navmesh from Tiled. Currently assumes that the polygons are squares! Does not support\r\n   * tilemap layer scaling, rotation or position.\r\n   *\r\n   * @param {string} key Key to use when storign this navmesh within the plugin.\r\n   * @param {Phaser.Tilemaps.ObjectLayer} objectLayer The ObjectLayer from a tilemap that contains\r\n   * the polygons that make up the navmesh.\r\n   * @param {number} [meshShrinkAmount=0] The amount (in pixels) that the navmesh has been shrunk\r\n   * around obstacles (a.k.a the amount obstacles have been expanded)\r\n   * @returns {Phaser2NavMesh}\r\n   * @memberof Phaser2NavMeshPlugin\r\n   */\r\n  buildMeshFromTiled(key, objectLayer, meshShrinkAmount = 0) {\r\n    if (this.phaserNavMeshes[key]) {\r\n      console.warn(`NavMeshPlugin: a navmesh already exists with the given key: ${key}`);\r\n      return this.phaserNavMeshes[key];\r\n    }\r\n\r\n    if (!objectLayer || objectLayer.length === 0) {\r\n      console.warn(\r\n        `NavMeshPlugin: The given tilemap object layer is empty or undefined: ${objectLayer}`\r\n      );\r\n    }\r\n\r\n    // Load up the object layer\r\n    const objects = objectLayer || [];\r\n\r\n    // Loop over the objects and construct a polygon - assumes a rectangle for now!\r\n    // TODO: support layer position, scale, rotation\r\n    const polygons = objects.map(obj => {\r\n      const top = obj.y;\r\n      const bottom = obj.y + obj.height;\r\n      const left = obj.x;\r\n      const right = obj.x + obj.width;\r\n      return [\r\n        { x: left, y: top },\r\n        { x: left, y: bottom },\r\n        { x: right, y: bottom },\r\n        { x: right, y: top }\r\n      ];\r\n    });\r\n\r\n    const mesh = new Phaser2NavMesh(this, key, polygons, meshShrinkAmount);\r\n\r\n    this.phaserNavMeshes[key] = mesh;\r\n\r\n    return mesh;\r\n  }\r\n}\r\n","import Phaser2NavMeshPlugin from \"./phaser2-navmesh-plugin\";\r\nimport Phaser2NavMesh from \"./phaser2-navmesh\";\r\n\r\nexport default Phaser2NavMeshPlugin;\r\nexport { Phaser2NavMesh };\r\n"],"sourceRoot":""}