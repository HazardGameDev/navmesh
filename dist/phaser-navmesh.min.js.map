{"version":3,"sources":["webpack:///webpack/universalModuleDefinition?5ca6","webpack:///phaser-navmesh.min.js","webpack:///webpack/bootstrap 1e1f6e5e13802be39203?e03c","webpack:///./utils.js?e8fb","webpack:///E:/Github/navmesh-phaser-plugin/~/javascript-astar/astar.js?e4f8","webpack:///./nav-mesh-plugin.js?5f0d","webpack:///./channel.js?5df9","webpack:///./index.js?2645","webpack:///./nav-graph.js?63ca","webpack:///./nav-mesh.js?f576","webpack:///./nav-poly.js?b51a"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","triarea2","a","b","ax","x","ay","y","almostEqual","value1","value2","errorMargin","arguments","length","undefined","Math","abs","angleDifference","PI","j","floor","areCollinear","line1","line2","area1","start","end","area2","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","definition","apply","pathTo","node","curr","path","parent","unshift","getHeap","BinaryHeap","f","Graph","gridIn","options","nodes","diagonal","grid","row","GridNode","push","init","weight","scoreFunction","content","astar","search","graph","cleanDirty","heuristic","heuristics","manhattan","closest","openHeap","closestNode","h","markDirty","size","currentNode","pop","closed","neighbors","il","neighbor","isWall","gScore","g","getCost","beenVisited","visited","rescoreElement","pos0","pos1","D2","sqrt","d1","d2","min","cleanNode","dirtyNodes","ret","toString","graphString","rowDebug","join","fromNeighbor","element","sinkDown","result","bubbleUp","remove","indexOf","parentN","elemScore","child1Score","child2N","child1N","swap","child1","child2","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","constructor","writable","setPrototypeOf","__proto__","__WEBPACK_IMPORTED_MODULE_0__nav_mesh__","_createClass","defineProperties","target","props","descriptor","key","protoProps","staticProps","_get","receiver","Function","desc","getOwnPropertyDescriptor","getPrototypeOf","NavMeshPlugin","_Phaser$Plugin","game","manager","_this","_navMeshes","tilemap","objectKey","meshShrinkAmount","objects","console","warn","rects","polygons","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","Symbol","iterator","next","done","r","top","bottom","height","left","right","width","poly","Phaser","Polygon","err","return","mesh","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","destroy","Plugin","__WEBPACK_IMPORTED_MODULE_0__utils__","Channel","portals","p1","p2","portalApex","portalLeft","portalRight","pts","apexIndex","leftIndex","rightIndex","equals","default","__WEBPACK_IMPORTED_MODULE_0_javascript_astar__","__WEBPACK_IMPORTED_MODULE_0_javascript_astar___default","NavGraph","navPolygons","navPolygon","navPolygon1","navPolygon2","centroidDistance","_toConsumableArray","arr","Array","isArray","arr2","from","__WEBPACK_IMPORTED_MODULE_1__nav_poly__","__WEBPACK_IMPORTED_MODULE_2__nav_graph__","__WEBPACK_IMPORTED_MODULE_3__channel__","__WEBPACK_IMPORTED_MODULE_4__utils__","_slicedToArray","sliceIterator","_arr","_n","_d","_e","_s","_i","NavMesh","_debugGraphics","_meshShrinkAmount","_navPolygons","entries","_ref","_ref2","polygon","_calculateNeighbors","_graph","disableDebug","startPoint","endPoint","_ref3","_ref3$drawPolyPath","drawPolyPath","_ref3$drawFinalPath","drawFinalPath","startPoly","endPoly","startDistance","Number","MAX_VALUE","endDistance","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","navPoly","boundingRadius","centroid","distance","contains","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_step4","_iterator4","_projectPointToPolygo","_projectPointToPolygon","_iteratorNormalCompletion5","_didIteratorError5","_iteratorError5","_step5","_iterator5","_projectPointToPolygo2","phaserPath","clone","debugDrawPath","astarPath","navHeuristic","channel","nextNavPolygon","portal","id","stringPull","lastPoint","_iteratorNormalCompletion6","_didIteratorError6","_iteratorError6","_step6","_iterator6","newPoint","polyPath","map","elem","otherNavPoly","_iteratorNormalCompletion7","_didIteratorError7","_iteratorError7","_step7","_iterator7","edges","edge","_iteratorNormalCompletion8","_didIteratorError8","_iteratorError8","_step8","_iterator8","otherEdge","overlap","_getSegmentOverlap","_overlap","edgeStartAngle","angle","a1","a2","Line","points","line","point","sort","noOverlap","singlePointOverlap","closestProjection","closestDistance","_iteratorNormalCompletion9","_didIteratorError9","_iteratorError9","_step9","_iterator9","projectedPoint","_projectPointToEdge","dx","dy","l2","_distanceSquared","t","clamp","Point","add","graphics","alpha","clear","_ref4","_ref4$drawCentroid","drawCentroid","_ref4$drawBounds","drawBounds","_ref4$drawNeighbors","drawNeighbors","_ref4$drawPortals","drawPortals","enableDebug","_iteratorNormalCompletion10","_didIteratorError10","_iteratorError10","_step10","_iterator10","draw","color","thickness","lineStyle","drawShape","bind","concat","beginFill","drawEllipse","endFill","palette","NavPoly","_calculateEdges","_calculateCentroid","_calculateRadius","_color","_isPointOnEdge","first","last","divide","pointOnSegment","lineWidth","drawPolygon","moveTo","lineTo"],"mappings":"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","file":"phaser-navmesh.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"PhaserNavmesh\"] = factory();\n\telse\n\t\troot[\"PhaserNavmesh\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"PhaserNavmesh\"] = factory();\n\telse\n\t\troot[\"PhaserNavmesh\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 4);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"c\"] = triarea2;\n/* unused harmony export almostEqual */\n/* harmony export (immutable) */ __webpack_exports__[\"b\"] = angleDifference;\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = areCollinear;\n/**\r\n * Twice the area of the triangle formed by a, b and c\r\n * @private\r\n */\nfunction triarea2(a, b, c) {\n  var ax = b.x - a.x;\n  var ay = b.y - a.y;\n  var bx = c.x - a.x;\n  var by = c.y - a.y;\n  return bx * ay - ax * by;\n}\n\n/**\r\n * @private\r\n */\nfunction almostEqual(value1, value2) {\n  var errorMargin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.0001;\n\n  if (Math.abs(value1 - value2) <= errorMargin) return true;else return false;\n}\n\n/**\r\n * https://gist.github.com/Aaronduino/4068b058f8dbc34b4d3a9eedc8b2cbe0\r\n * @private\r\n */\nfunction angleDifference(x, y) {\n  var a = x - y;\n  var i = a + Math.PI;\n  var j = Math.PI * 2;\n  a = i - Math.floor(i / j) * j; // (a+180) % 360; this ensures the correct sign\n  a -= Math.PI;\n  return a;\n}\n\n/**\r\n * @private\r\n */\nfunction areCollinear(line1, line2) {\n  var errorMargin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.0001;\n\n  // Figure out if the two lines are equal by looking at the area of the triangle formed\n  // by their points\n  var area1 = triarea2(line1.start, line1.end, line2.start);\n  var area2 = triarea2(line1.start, line1.end, line2.end);\n  if (almostEqual(area1, 0, errorMargin) && almostEqual(area2, 0, errorMargin)) {\n    return true;\n  } else return false;\n}\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// javascript-astar 0.4.2\r\n// http://github.com/bgrins/javascript-astar\r\n// Freely distributable under the MIT License.\r\n// Implements the astar search algorithm in javascript using a Binary Heap.\r\n// Includes Binary Heap (with modifications) from Marijn Haverbeke.\r\n// http://eloquentjavascript.net/appendix2.html\r\n(function(definition) {\r\n  /* global module, define */\r\n  if (typeof module === 'object' && typeof module.exports === 'object') {\r\n    module.exports = definition();\r\n  } else if (true) {\r\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (definition),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n  } else {\r\n    var exports = definition();\r\n    window.astar = exports.astar;\r\n    window.Graph = exports.Graph;\r\n  }\r\n})(function() {\r\n\r\nfunction pathTo(node) {\r\n  var curr = node;\r\n  var path = [];\r\n  while (curr.parent) {\r\n    path.unshift(curr);\r\n    curr = curr.parent;\r\n  }\r\n  return path;\r\n}\r\n\r\nfunction getHeap() {\r\n  return new BinaryHeap(function(node) {\r\n    return node.f;\r\n  });\r\n}\r\n\r\nvar astar = {\r\n  /**\r\n  * Perform an A* Search on a graph given a start and end node.\r\n  * @param {Graph} graph\r\n  * @param {GridNode} start\r\n  * @param {GridNode} end\r\n  * @param {Object} [options]\r\n  * @param {bool} [options.closest] Specifies whether to return the\r\n             path to the closest node if the target is unreachable.\r\n  * @param {Function} [options.heuristic] Heuristic function (see\r\n  *          astar.heuristics).\r\n  */\r\n  search: function(graph, start, end, options) {\r\n    graph.cleanDirty();\r\n    options = options || {};\r\n    var heuristic = options.heuristic || astar.heuristics.manhattan;\r\n    var closest = options.closest || false;\r\n\r\n    var openHeap = getHeap();\r\n    var closestNode = start; // set the start node to be the closest if required\r\n\r\n    start.h = heuristic(start, end);\r\n    graph.markDirty(start);\r\n\r\n    openHeap.push(start);\r\n\r\n    while (openHeap.size() > 0) {\r\n\r\n      // Grab the lowest f(x) to process next.  Heap keeps this sorted for us.\r\n      var currentNode = openHeap.pop();\r\n\r\n      // End case -- result has been found, return the traced path.\r\n      if (currentNode === end) {\r\n        return pathTo(currentNode);\r\n      }\r\n\r\n      // Normal case -- move currentNode from open to closed, process each of its neighbors.\r\n      currentNode.closed = true;\r\n\r\n      // Find all neighbors for the current node.\r\n      var neighbors = graph.neighbors(currentNode);\r\n\r\n      for (var i = 0, il = neighbors.length; i < il; ++i) {\r\n        var neighbor = neighbors[i];\r\n\r\n        if (neighbor.closed || neighbor.isWall()) {\r\n          // Not a valid node to process, skip to next neighbor.\r\n          continue;\r\n        }\r\n\r\n        // The g score is the shortest distance from start to current node.\r\n        // We need to check if the path we have arrived at this neighbor is the shortest one we have seen yet.\r\n        var gScore = currentNode.g + neighbor.getCost(currentNode);\r\n        var beenVisited = neighbor.visited;\r\n\r\n        if (!beenVisited || gScore < neighbor.g) {\r\n\r\n          // Found an optimal (so far) path to this node.  Take score for node to see how good it is.\r\n          neighbor.visited = true;\r\n          neighbor.parent = currentNode;\r\n          neighbor.h = neighbor.h || heuristic(neighbor, end);\r\n          neighbor.g = gScore;\r\n          neighbor.f = neighbor.g + neighbor.h;\r\n          graph.markDirty(neighbor);\r\n          if (closest) {\r\n            // If the neighbour is closer than the current closestNode or if it's equally close but has\r\n            // a cheaper path than the current closest node then it becomes the closest node\r\n            if (neighbor.h < closestNode.h || (neighbor.h === closestNode.h && neighbor.g < closestNode.g)) {\r\n              closestNode = neighbor;\r\n            }\r\n          }\r\n\r\n          if (!beenVisited) {\r\n            // Pushing to heap will put it in proper place based on the 'f' value.\r\n            openHeap.push(neighbor);\r\n          } else {\r\n            // Already seen the node, but since it has been rescored we need to reorder it in the heap\r\n            openHeap.rescoreElement(neighbor);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (closest) {\r\n      return pathTo(closestNode);\r\n    }\r\n\r\n    // No result was found - empty array signifies failure to find path.\r\n    return [];\r\n  },\r\n  // See list of heuristics: http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html\r\n  heuristics: {\r\n    manhattan: function(pos0, pos1) {\r\n      var d1 = Math.abs(pos1.x - pos0.x);\r\n      var d2 = Math.abs(pos1.y - pos0.y);\r\n      return d1 + d2;\r\n    },\r\n    diagonal: function(pos0, pos1) {\r\n      var D = 1;\r\n      var D2 = Math.sqrt(2);\r\n      var d1 = Math.abs(pos1.x - pos0.x);\r\n      var d2 = Math.abs(pos1.y - pos0.y);\r\n      return (D * (d1 + d2)) + ((D2 - (2 * D)) * Math.min(d1, d2));\r\n    }\r\n  },\r\n  cleanNode: function(node) {\r\n    node.f = 0;\r\n    node.g = 0;\r\n    node.h = 0;\r\n    node.visited = false;\r\n    node.closed = false;\r\n    node.parent = null;\r\n  }\r\n};\r\n\r\n/**\r\n * A graph memory structure\r\n * @param {Array} gridIn 2D array of input weights\r\n * @param {Object} [options]\r\n * @param {bool} [options.diagonal] Specifies whether diagonal moves are allowed\r\n */\r\nfunction Graph(gridIn, options) {\r\n  options = options || {};\r\n  this.nodes = [];\r\n  this.diagonal = !!options.diagonal;\r\n  this.grid = [];\r\n  for (var x = 0; x < gridIn.length; x++) {\r\n    this.grid[x] = [];\r\n\r\n    for (var y = 0, row = gridIn[x]; y < row.length; y++) {\r\n      var node = new GridNode(x, y, row[y]);\r\n      this.grid[x][y] = node;\r\n      this.nodes.push(node);\r\n    }\r\n  }\r\n  this.init();\r\n}\r\n\r\nGraph.prototype.init = function() {\r\n  this.dirtyNodes = [];\r\n  for (var i = 0; i < this.nodes.length; i++) {\r\n    astar.cleanNode(this.nodes[i]);\r\n  }\r\n};\r\n\r\nGraph.prototype.cleanDirty = function() {\r\n  for (var i = 0; i < this.dirtyNodes.length; i++) {\r\n    astar.cleanNode(this.dirtyNodes[i]);\r\n  }\r\n  this.dirtyNodes = [];\r\n};\r\n\r\nGraph.prototype.markDirty = function(node) {\r\n  this.dirtyNodes.push(node);\r\n};\r\n\r\nGraph.prototype.neighbors = function(node) {\r\n  var ret = [];\r\n  var x = node.x;\r\n  var y = node.y;\r\n  var grid = this.grid;\r\n\r\n  // West\r\n  if (grid[x - 1] && grid[x - 1][y]) {\r\n    ret.push(grid[x - 1][y]);\r\n  }\r\n\r\n  // East\r\n  if (grid[x + 1] && grid[x + 1][y]) {\r\n    ret.push(grid[x + 1][y]);\r\n  }\r\n\r\n  // South\r\n  if (grid[x] && grid[x][y - 1]) {\r\n    ret.push(grid[x][y - 1]);\r\n  }\r\n\r\n  // North\r\n  if (grid[x] && grid[x][y + 1]) {\r\n    ret.push(grid[x][y + 1]);\r\n  }\r\n\r\n  if (this.diagonal) {\r\n    // Southwest\r\n    if (grid[x - 1] && grid[x - 1][y - 1]) {\r\n      ret.push(grid[x - 1][y - 1]);\r\n    }\r\n\r\n    // Southeast\r\n    if (grid[x + 1] && grid[x + 1][y - 1]) {\r\n      ret.push(grid[x + 1][y - 1]);\r\n    }\r\n\r\n    // Northwest\r\n    if (grid[x - 1] && grid[x - 1][y + 1]) {\r\n      ret.push(grid[x - 1][y + 1]);\r\n    }\r\n\r\n    // Northeast\r\n    if (grid[x + 1] && grid[x + 1][y + 1]) {\r\n      ret.push(grid[x + 1][y + 1]);\r\n    }\r\n  }\r\n\r\n  return ret;\r\n};\r\n\r\nGraph.prototype.toString = function() {\r\n  var graphString = [];\r\n  var nodes = this.grid;\r\n  for (var x = 0; x < nodes.length; x++) {\r\n    var rowDebug = [];\r\n    var row = nodes[x];\r\n    for (var y = 0; y < row.length; y++) {\r\n      rowDebug.push(row[y].weight);\r\n    }\r\n    graphString.push(rowDebug.join(\" \"));\r\n  }\r\n  return graphString.join(\"\\n\");\r\n};\r\n\r\nfunction GridNode(x, y, weight) {\r\n  this.x = x;\r\n  this.y = y;\r\n  this.weight = weight;\r\n}\r\n\r\nGridNode.prototype.toString = function() {\r\n  return \"[\" + this.x + \" \" + this.y + \"]\";\r\n};\r\n\r\nGridNode.prototype.getCost = function(fromNeighbor) {\r\n  // Take diagonal weight into consideration.\r\n  if (fromNeighbor && fromNeighbor.x != this.x && fromNeighbor.y != this.y) {\r\n    return this.weight * 1.41421;\r\n  }\r\n  return this.weight;\r\n};\r\n\r\nGridNode.prototype.isWall = function() {\r\n  return this.weight === 0;\r\n};\r\n\r\nfunction BinaryHeap(scoreFunction) {\r\n  this.content = [];\r\n  this.scoreFunction = scoreFunction;\r\n}\r\n\r\nBinaryHeap.prototype = {\r\n  push: function(element) {\r\n    // Add the new element to the end of the array.\r\n    this.content.push(element);\r\n\r\n    // Allow it to sink down.\r\n    this.sinkDown(this.content.length - 1);\r\n  },\r\n  pop: function() {\r\n    // Store the first element so we can return it later.\r\n    var result = this.content[0];\r\n    // Get the element at the end of the array.\r\n    var end = this.content.pop();\r\n    // If there are any elements left, put the end element at the\r\n    // start, and let it bubble up.\r\n    if (this.content.length > 0) {\r\n      this.content[0] = end;\r\n      this.bubbleUp(0);\r\n    }\r\n    return result;\r\n  },\r\n  remove: function(node) {\r\n    var i = this.content.indexOf(node);\r\n\r\n    // When it is found, the process seen in 'pop' is repeated\r\n    // to fill up the hole.\r\n    var end = this.content.pop();\r\n\r\n    if (i !== this.content.length - 1) {\r\n      this.content[i] = end;\r\n\r\n      if (this.scoreFunction(end) < this.scoreFunction(node)) {\r\n        this.sinkDown(i);\r\n      } else {\r\n        this.bubbleUp(i);\r\n      }\r\n    }\r\n  },\r\n  size: function() {\r\n    return this.content.length;\r\n  },\r\n  rescoreElement: function(node) {\r\n    this.sinkDown(this.content.indexOf(node));\r\n  },\r\n  sinkDown: function(n) {\r\n    // Fetch the element that has to be sunk.\r\n    var element = this.content[n];\r\n\r\n    // When at 0, an element can not sink any further.\r\n    while (n > 0) {\r\n\r\n      // Compute the parent element's index, and fetch it.\r\n      var parentN = ((n + 1) >> 1) - 1;\r\n      var parent = this.content[parentN];\r\n      // Swap the elements if the parent is greater.\r\n      if (this.scoreFunction(element) < this.scoreFunction(parent)) {\r\n        this.content[parentN] = element;\r\n        this.content[n] = parent;\r\n        // Update 'n' to continue at the new position.\r\n        n = parentN;\r\n      }\r\n      // Found a parent that is less, no need to sink any further.\r\n      else {\r\n        break;\r\n      }\r\n    }\r\n  },\r\n  bubbleUp: function(n) {\r\n    // Look up the target element and its score.\r\n    var length = this.content.length;\r\n    var element = this.content[n];\r\n    var elemScore = this.scoreFunction(element);\r\n\r\n    while (true) {\r\n      // Compute the indices of the child elements.\r\n      var child2N = (n + 1) << 1;\r\n      var child1N = child2N - 1;\r\n      // This is used to store the new position of the element, if any.\r\n      var swap = null;\r\n      var child1Score;\r\n      // If the first child exists (is inside the array)...\r\n      if (child1N < length) {\r\n        // Look it up and compute its score.\r\n        var child1 = this.content[child1N];\r\n        child1Score = this.scoreFunction(child1);\r\n\r\n        // If the score is less than our element's, we need to swap.\r\n        if (child1Score < elemScore) {\r\n          swap = child1N;\r\n        }\r\n      }\r\n\r\n      // Do the same checks for the other child.\r\n      if (child2N < length) {\r\n        var child2 = this.content[child2N];\r\n        var child2Score = this.scoreFunction(child2);\r\n        if (child2Score < (swap === null ? elemScore : child1Score)) {\r\n          swap = child2N;\r\n        }\r\n      }\r\n\r\n      // If the element needs to be moved, swap it, and continue.\r\n      if (swap !== null) {\r\n        this.content[n] = this.content[swap];\r\n        this.content[swap] = element;\r\n        n = swap;\r\n      }\r\n      // Otherwise, we are done.\r\n      else {\r\n        break;\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nreturn {\r\n  astar: astar,\r\n  Graph: Graph\r\n};\r\n\r\n});\n\n/***/ }),\n/* 2 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__nav_mesh__ = __webpack_require__(6);\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n// const triangulate = require(\"./triangulate\");\n\n\n/**\r\n * This plugin can create navigation meshes for use in Phaser. The navmeshes can be constructed from\r\n * convex polygons embedded in a Tiled map. Instantiate this using game.plugins.add(NavMeshPlugin).\r\n *\r\n * @param {Phaser.Game} game\r\n * @param {Phaser.PluginManager} manager\r\n */\n\nvar NavMeshPlugin = function (_Phaser$Plugin) {\n  _inherits(NavMeshPlugin, _Phaser$Plugin);\n\n  function NavMeshPlugin(game, manager) {\n    _classCallCheck(this, NavMeshPlugin);\n\n    var _this = _possibleConstructorReturn(this, (NavMeshPlugin.__proto__ || Object.getPrototypeOf(NavMeshPlugin)).call(this, game, manager));\n\n    _this._navMeshes = [];\n    return _this;\n  }\n\n  /**\r\n   * Load a navmesh from Tiled and switch it to be the current navmesh. Currently assumes that the\r\n   * polygons are squares!\r\n   * \r\n   * @param {Phaser.Tilemap} tilemap The tilemap that contains polygons under an object layer\r\n   * @param {string} objectKey The name of the object layer in the tilemap\r\n   * @param {number} [meshShrinkAmount=0] The amount (in pixels) that the navmesh has been\r\n   * shrunk around obstacles (a.k.a the amount obstacles have been expanded)\r\n   * \r\n   * @memberof NavMeshPlugin\r\n   */\n\n\n  _createClass(NavMeshPlugin, [{\n    key: \"buildMeshFromTiled\",\n    value: function buildMeshFromTiled(tilemap, objectKey) {\n      var meshShrinkAmount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n      if (!tilemap.objects[objectKey]) {\n        console.warn(\"NavMeshPlugin: The given tilemap has no object layer with the name \\\"\" + objectKey + \"\\\"\");\n      } else if (tilemap.objects[objectKey].length === 0) {\n        console.warn(\"NavMeshPlugin: The \\\"\" + objectKey + \"\\\" object layer in the Tilemap has 0 objects in it\");\n      }\n      // Load up the object layer\n      var rects = tilemap.objects[objectKey] || [];\n      // Loop over the objects and construct a polygon\n      var polygons = [];\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = rects[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var r = _step.value;\n\n          var top = r.y;\n          var bottom = r.y + r.height;\n          var left = r.x;\n          var right = r.x + r.width;\n          var poly = new Phaser.Polygon(left, top, left, bottom, right, bottom, right, top);\n          polygons.push(poly);\n        }\n        // Build the navmesh\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      var mesh = new __WEBPACK_IMPORTED_MODULE_0__nav_mesh__[\"a\" /* default */](this.game, polygons, meshShrinkAmount);\n      this._navMeshes.push(mesh);\n      return mesh;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = this._navMeshes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var mesh = _step2.value;\n          mesh.destroy();\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      this._navMeshes = [];\n      _get(NavMeshPlugin.prototype.__proto__ || Object.getPrototypeOf(NavMeshPlugin.prototype), \"destroy\", this).call(this);\n    }\n\n    // /**\n    //  * Build a navmesh from an array of convex polygons. This currently tesselates the polygons into\n    //  * triangles. They aren't as efficient or as well designed as ones made by hand in Tiled.\n    //  *\n    //  * @param {string} levelName The key to use to store the navmesh in the plugin\n    //  * @param {[]} hulls An array of convex polygons describing the obstacles in the\n    //  * level. See lighting-plugin/hull-from-tiles.\n    //  *\n    //  * @memberof NavMeshPlugin\n    //  */\n    // buildMesh(levelName, hulls) {\n    //     const contours = this._buildContours(hulls);\n    //     // Get an array of triangulated vertices\n    //     const triangles = triangulate(contours, false); // Counter-clockwise ordering!\n    //     const polygons = [];\n    //     for (let i = 0; i < triangles.length; i += 6) {\n    //         const poly = new Phaser.Polygon(\n    //             // These should be in counter-clockwise order from triangulate\n    //             triangles[i + 0], triangles[i + 1],\n    //             triangles[i + 2], triangles[i + 3],\n    //             triangles[i + 4], triangles[i + 5]\n    //         );\n    //         polygons.push(poly);\n    //     }\n    //     const navMesh = new NavMesh(this.game, polygons);\n    //     this._navMeshes[levelName] = navMesh;\n    //     this._currentNavMesh = navMesh;\n    // }\n\n    // /**\n    //  * @param {[]} hulls\n    //  * @returns\n    //  *\n    //  * @memberof NavMeshPlugin\n    //  */\n    // _buildContours(hulls) {\n    //     const w = this.game.width;\n    //     const h = this.game.height;\n    //     // Start the contours\n    //     const contours = [\n    //         // Full screen - counter clockwise\n    //         Float32Array.of(0,0, 0,h, w,h, w,0)\n    //     ];\n    //     // For each convex hull add the contour\n    //     for (const hull of hulls) {\n    //         const contour = [];\n    //         for (const lineInfo of hull) {\n    //             contour.push(lineInfo.line.start.x, lineInfo.line.start.y);\n    //         }\n    //         contours.push(Float32Array.from(contour));\n    //     }\n    //     return contours;\n    // }\n\n  }]);\n\n  return NavMeshPlugin;\n}(Phaser.Plugin);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (NavMeshPlugin);\n\n/***/ }),\n/* 3 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils__ = __webpack_require__(0);\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// Mostly sourced from PatrolJS at the moment. TODO: come back and reimplement this as an incomplete\n// funnel algorithm so astar checks can be more accurate.\n\n\n\n/**\r\n * @private\r\n */\n\nvar Channel = function () {\n  function Channel() {\n    _classCallCheck(this, Channel);\n\n    this.portals = [];\n  }\n\n  /**\r\n   * @param {Phaser.Point} p1 \r\n   * @param {Phaser.Point} p2 \r\n   * \r\n   * @memberof Channel\r\n   */\n\n\n  _createClass(Channel, [{\n    key: \"push\",\n    value: function push(p1) {\n      var p2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      if (p2 === null) p2 = p1;\n      this.portals.push({\n        left: p1,\n        right: p2\n      });\n    }\n  }, {\n    key: \"stringPull\",\n    value: function stringPull() {\n      var portals = this.portals;\n      var pts = [];\n      // Init scan state\n      var portalApex, portalLeft, portalRight;\n      var apexIndex = 0,\n          leftIndex = 0,\n          rightIndex = 0;\n\n      portalApex = portals[0].left;\n      portalLeft = portals[0].left;\n      portalRight = portals[0].right;\n\n      // Add start point.\n      pts.push(portalApex);\n\n      for (var i = 1; i < portals.length; i++) {\n        // Find the next portal vertices\n        var left = portals[i].left;\n        var right = portals[i].right;\n\n        // Update right vertex.\n        if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__[\"c\" /* triarea2 */])(portalApex, portalRight, right) <= 0.0) {\n          if (portalApex.equals(portalRight) || __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__[\"c\" /* triarea2 */])(portalApex, portalLeft, right) > 0.0) {\n            // Tighten the funnel.\n            portalRight = right;\n            rightIndex = i;\n          } else {\n            // Right vertex just crossed over the left vertex, so the left vertex should\n            // now be part of the path.\n            pts.push(portalLeft);\n\n            // Restart scan from portal left point.\n\n            // Make current left the new apex.\n            portalApex = portalLeft;\n            apexIndex = leftIndex;\n            // Reset portal\n            portalLeft = portalApex;\n            portalRight = portalApex;\n            leftIndex = apexIndex;\n            rightIndex = apexIndex;\n            // Restart scan\n            i = apexIndex;\n            continue;\n          }\n        }\n\n        // Update left vertex.\n        if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__[\"c\" /* triarea2 */])(portalApex, portalLeft, left) >= 0.0) {\n          if (portalApex.equals(portalLeft) || __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__[\"c\" /* triarea2 */])(portalApex, portalRight, left) < 0.0) {\n            // Tighten the funnel.\n            portalLeft = left;\n            leftIndex = i;\n          } else {\n            // Left vertex just crossed over the right vertex, so the right vertex should\n            // now be part of the path\n            pts.push(portalRight);\n\n            // Restart scan from portal right point.\n\n            // Make current right the new apex.\n            portalApex = portalRight;\n            apexIndex = rightIndex;\n            // Reset portal\n            portalLeft = portalApex;\n            portalRight = portalApex;\n            leftIndex = apexIndex;\n            rightIndex = apexIndex;\n            // Restart scan\n            i = apexIndex;\n            continue;\n          }\n        }\n      }\n\n      if (pts.length === 0 || !pts[pts.length - 1].equals(portals[portals.length - 1].left)) {\n        // Append last point to path.\n        pts.push(portals[portals.length - 1].left);\n      }\n\n      this.path = pts;\n      return pts;\n    }\n  }]);\n\n  return Channel;\n}();\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Channel);\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// Fix for webpack not exporting ES6 module default properly when using global mode of UMD. It ends\n// up with someone having to do \"PhaserNavmesh.default\" instead of \"PhaserNavmesh\"\nmodule.exports = __webpack_require__(2).default;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_javascript_astar__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_javascript_astar___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_javascript_astar__);\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\n\n/**\r\n * Graph for javascript-astar. It implements the functionality for astar. See GPS test from astar\r\n * repo for structure: https://github.com/bgrins/javascript-astar/blob/master/test/tests.js\r\n *\r\n * @class NavGraph \r\n * @private\r\n */\n\nvar NavGraph = function () {\n  function NavGraph(navPolygons) {\n    _classCallCheck(this, NavGraph);\n\n    this.nodes = navPolygons;\n    this.init();\n  }\n\n  _createClass(NavGraph, [{\n    key: \"neighbors\",\n    value: function neighbors(navPolygon) {\n      return navPolygon.neighbors;\n    }\n  }, {\n    key: \"navHeuristic\",\n    value: function navHeuristic(navPolygon1, navPolygon2) {\n      return navPolygon1.centroidDistance(navPolygon2);\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.cleanDirty();\n      this.nodes = [];\n    }\n  }]);\n\n  return NavGraph;\n}();\n\nNavGraph.prototype.init = __WEBPACK_IMPORTED_MODULE_0_javascript_astar___default.a.Graph.prototype.init;\nNavGraph.prototype.cleanDirty = __WEBPACK_IMPORTED_MODULE_0_javascript_astar___default.a.Graph.prototype.cleanDirty;\nNavGraph.prototype.markDirty = __WEBPACK_IMPORTED_MODULE_0_javascript_astar___default.a.Graph.prototype.markDirty;\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (NavGraph);\n\n/***/ }),\n/* 6 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_javascript_astar__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_javascript_astar___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_javascript_astar__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__nav_poly__ = __webpack_require__(7);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__nav_graph__ = __webpack_require__(5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__channel__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__utils__ = __webpack_require__(0);\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\n\n\n\n\n\n/**\r\n * The workhorse that represents a navigation mesh built from a series of polygons. Once built, the\r\n * mesh can be asked for a path from one point to another point. It has debug methods for \r\n * visualizing paths and visualizing the individual polygons. Some internal terminology usage:\r\n * \r\n * - neighbor: a polygon that shares part of an edge with another polygon\r\n * - portal: when two neighbor's have edges that overlap, the portal is the overlapping line segment\r\n * - channel: the path of polygons from starting point to end point\r\n * - pull the string: run the funnel algorithm on the channel so that the path hugs the edges of the\r\n *   channel. Equivalent to having a string snaking through a hallway and then pulling it taut.\r\n */\n\nvar NavMesh = function () {\n  /**\r\n   * Creates an instance of NavMesh.\r\n   * \r\n   * @param {Phaser.Game} game\r\n   * @param {Phaser.Polygon[]} polygons\r\n   * @param {number} [meshShrinkAmount=0] The amount (in pixels) that the navmesh has been\r\n   * shrunk around obstacles (a.k.a the amount obstacles have been expanded)\r\n   */\n  function NavMesh(game, polygons) {\n    var meshShrinkAmount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n    _classCallCheck(this, NavMesh);\n\n    this.game = game;\n    this._debugGraphics = null;\n    this._meshShrinkAmount = meshShrinkAmount;\n\n    // Construct NavPoly instances for each polygon\n    this._navPolygons = [];\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = polygons.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var _ref = _step.value;\n\n        var _ref2 = _slicedToArray(_ref, 2);\n\n        var i = _ref2[0];\n        var polygon = _ref2[1];\n\n        this._navPolygons.push(new __WEBPACK_IMPORTED_MODULE_1__nav_poly__[\"a\" /* default */](game, i, polygon));\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    this._calculateNeighbors();\n\n    // Astar graph of connections between polygons\n    this._graph = new __WEBPACK_IMPORTED_MODULE_2__nav_graph__[\"a\" /* default */](this._navPolygons);\n  }\n\n  /**\r\n   * Cleanup method to remove references so that navmeshes don't hang around from state to state.\r\n   * You don't have to invoke this directly. If you call destroy on the plugin, it will destroy\r\n   * all navmeshes that have been created. \r\n   * \r\n   * @memberof NavMesh\r\n   */\n\n\n  _createClass(NavMesh, [{\n    key: \"destroy\",\n    value: function destroy() {\n      this._graph.destroy();\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = this._navPolygons[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var poly = _step2.value;\n          poly.destroy();\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      this._navPolygons = [];\n      this.game = null;\n      this.disableDebug();\n    }\n\n    /**\r\n     * Find a path from the start point to the end point using this nav mesh.\r\n     *\r\n     * @param {Phaser.Point} startPoint\r\n     * @param {Phaser.Point} endPoint\r\n     * @param {object} [drawOptions={}] Options for controlling debug drawing\r\n     * @param {boolean} [drawOptions.drawPolyPath=false] Whether or not to visualize the path\r\n     * through the polygons - e.g. the path that astar found.\r\n     * @param {boolean} [drawOptions.drawFinalPath=false] Whether or not to visualize the path\r\n     * through the path that was returned.\r\n     * @returns {Phaser.Point[]|null} An array of points if a path is found, or null if no path\r\n     *\r\n     * @memberof NavMesh\r\n     */\n\n  }, {\n    key: \"findPath\",\n    value: function findPath(startPoint, endPoint) {\n      var _ref3 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n          _ref3$drawPolyPath = _ref3.drawPolyPath,\n          drawPolyPath = _ref3$drawPolyPath === undefined ? false : _ref3$drawPolyPath,\n          _ref3$drawFinalPath = _ref3.drawFinalPath,\n          drawFinalPath = _ref3$drawFinalPath === undefined ? false : _ref3$drawFinalPath;\n\n      var startPoly = null;\n      var endPoly = null;\n      var startDistance = Number.MAX_VALUE;\n      var endDistance = Number.MAX_VALUE;\n      var d = void 0,\n          r = void 0;\n\n      // Find the closest poly for the starting and ending point\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = this._navPolygons[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var navPoly = _step3.value;\n\n          r = navPoly.boundingRadius;\n          // Start\n          d = navPoly.centroid.distance(startPoint);\n          if (d <= startDistance && d <= r && navPoly.contains(startPoint)) {\n            startPoly = navPoly;\n            startDistance = d;\n          }\n          // End\n          d = navPoly.centroid.distance(endPoint);\n          if (d <= endDistance && d <= r && navPoly.contains(endPoint)) {\n            endPoly = navPoly;\n            endDistance = d;\n          }\n        }\n\n        // If the start point wasn't inside a polygon, run a more liberal check that allows a point\n        // to be within meshShrinkAmount radius of a polygon\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      if (!startPoly && this._meshShrinkAmount > 0) {\n        var _iteratorNormalCompletion4 = true;\n        var _didIteratorError4 = false;\n        var _iteratorError4 = undefined;\n\n        try {\n          for (var _iterator4 = this._navPolygons[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n            var _navPoly = _step4.value;\n\n            // Check if point is within bounding circle to avoid extra projection calculations\n            r = _navPoly.boundingRadius + this._meshShrinkAmount;\n            d = _navPoly.centroid.distance(startPoint);\n            if (d <= r) {\n              // Check if projected point is within range of a polgyon and is closer than the\n              // previous point\n              var _projectPointToPolygo = this._projectPointToPolygon(startPoint, _navPoly),\n                  distance = _projectPointToPolygo.distance;\n\n              if (distance <= this._meshShrinkAmount && distance < startDistance) {\n                startPoly = _navPoly;\n                startDistance = distance;\n              }\n            }\n          }\n        } catch (err) {\n          _didIteratorError4 = true;\n          _iteratorError4 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion4 && _iterator4.return) {\n              _iterator4.return();\n            }\n          } finally {\n            if (_didIteratorError4) {\n              throw _iteratorError4;\n            }\n          }\n        }\n      }\n\n      // Same check as above, but for the end point\n      if (!endPoly && this._meshShrinkAmount > 0) {\n        var _iteratorNormalCompletion5 = true;\n        var _didIteratorError5 = false;\n        var _iteratorError5 = undefined;\n\n        try {\n          for (var _iterator5 = this._navPolygons[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n            var _navPoly2 = _step5.value;\n\n            r = _navPoly2.boundingRadius + this._meshShrinkAmount;\n            d = _navPoly2.centroid.distance(endPoint);\n            if (d <= r) {\n              var _projectPointToPolygo2 = this._projectPointToPolygon(endPoint, _navPoly2),\n                  _distance = _projectPointToPolygo2.distance;\n\n              if (_distance <= this._meshShrinkAmount && _distance < endDistance) {\n                endPoly = _navPoly2;\n                endDistance = _distance;\n              }\n            }\n          }\n        } catch (err) {\n          _didIteratorError5 = true;\n          _iteratorError5 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion5 && _iterator5.return) {\n              _iterator5.return();\n            }\n          } finally {\n            if (_didIteratorError5) {\n              throw _iteratorError5;\n            }\n          }\n        }\n      }\n\n      // No matching polygons locations for the start or end, so no path found\n      if (!startPoly || !endPoly) return null;\n\n      // If the start and end polygons are the same, return a direct path\n      if (startPoly === endPoly) {\n        var _phaserPath = [startPoint.clone(), endPoint.clone()];\n        if (drawFinalPath) this.debugDrawPath(_phaserPath, 0xffd900, 10);\n        return _phaserPath;\n      }\n\n      // Search!\n      var astarPath = __WEBPACK_IMPORTED_MODULE_0_javascript_astar___default.a.astar.search(this._graph, startPoly, endPoly, {\n        heuristic: this._graph.navHeuristic\n      });\n\n      // While the start and end polygons may be valid, no path between them\n      if (astarPath.length === 0) return null;\n\n      // jsastar drops the first point from the path, but the funnel algorithm needs it\n      astarPath.unshift(startPoly);\n\n      // We have a path, so now time for the funnel algorithm\n      var channel = new __WEBPACK_IMPORTED_MODULE_3__channel__[\"a\" /* default */]();\n      channel.push(startPoint);\n      for (var i = 0; i < astarPath.length - 1; i++) {\n        var navPolygon = astarPath[i];\n        var nextNavPolygon = astarPath[i + 1];\n\n        // Find the portal\n        var portal = null;\n        for (var _i = 0; _i < navPolygon.neighbors.length; _i++) {\n          if (navPolygon.neighbors[_i].id === nextNavPolygon.id) {\n            portal = navPolygon.portals[_i];\n          }\n        }\n\n        // Push the portal vertices into the channel\n        channel.push(portal.start, portal.end);\n      }\n      channel.push(endPoint);\n\n      // Pull a string along the channel to run the funnel\n      channel.stringPull();\n\n      // Clone path, excluding duplicates\n      var lastPoint = null;\n      var phaserPath = [];\n      var _iteratorNormalCompletion6 = true;\n      var _didIteratorError6 = false;\n      var _iteratorError6 = undefined;\n\n      try {\n        for (var _iterator6 = channel.path[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n          var p = _step6.value;\n\n          var newPoint = p.clone();\n          if (!lastPoint || !newPoint.equals(lastPoint)) phaserPath.push(newPoint);\n          lastPoint = newPoint;\n        }\n\n        // Call debug drawing\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion6 && _iterator6.return) {\n            _iterator6.return();\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n\n      if (drawPolyPath) {\n        var polyPath = astarPath.map(function (elem) {\n          return elem.centroid;\n        });\n        this.debugDrawPath(polyPath, 0x00ff00, 5);\n      }\n      if (drawFinalPath) this.debugDrawPath(phaserPath, 0xffd900, 10);\n\n      return phaserPath;\n    }\n  }, {\n    key: \"_calculateNeighbors\",\n    value: function _calculateNeighbors() {\n      // Fill out the neighbor information for each navpoly\n      for (var i = 0; i < this._navPolygons.length; i++) {\n        var navPoly = this._navPolygons[i];\n\n        for (var j = i + 1; j < this._navPolygons.length; j++) {\n          var otherNavPoly = this._navPolygons[j];\n\n          // Check if the other navpoly is within range to touch\n          var d = navPoly.centroid.distance(otherNavPoly.centroid);\n          if (d > navPoly.boundingRadius + otherNavPoly.boundingRadius) continue;\n\n          // The are in range, so check each edge pairing\n          var _iteratorNormalCompletion7 = true;\n          var _didIteratorError7 = false;\n          var _iteratorError7 = undefined;\n\n          try {\n            for (var _iterator7 = navPoly.edges[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n              var edge = _step7.value;\n              var _iteratorNormalCompletion8 = true;\n              var _didIteratorError8 = false;\n              var _iteratorError8 = undefined;\n\n              try {\n                for (var _iterator8 = otherNavPoly.edges[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n                  var otherEdge = _step8.value;\n\n                  // If edges aren't collinear, not an option for connecting navpolys\n                  if (!__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__utils__[\"a\" /* areCollinear */])(edge, otherEdge)) continue;\n\n                  // If they are collinear, check if they overlap\n                  var overlap = this._getSegmentOverlap(edge, otherEdge);\n                  if (!overlap) continue;\n\n                  // Connections are symmetric!\n                  navPoly.neighbors.push(otherNavPoly);\n                  otherNavPoly.neighbors.push(navPoly);\n\n                  // Calculate the portal between the two polygons - this needs to be in\n                  // counter-clockwise order, relative to each polygon\n\n                  var _overlap = _slicedToArray(overlap, 2),\n                      p1 = _overlap[0],\n                      p2 = _overlap[1];\n\n                  var edgeStartAngle = navPoly.centroid.angle(edge.start);\n                  var a1 = navPoly.centroid.angle(overlap[0]);\n                  var a2 = navPoly.centroid.angle(overlap[1]);\n                  var d1 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__utils__[\"b\" /* angleDifference */])(edgeStartAngle, a1);\n                  var d2 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__utils__[\"b\" /* angleDifference */])(edgeStartAngle, a2);\n                  if (d1 < d2) {\n                    navPoly.portals.push(new Phaser.Line(p1.x, p1.y, p2.x, p2.y));\n                  } else {\n                    navPoly.portals.push(new Phaser.Line(p2.x, p2.y, p1.x, p1.y));\n                  }\n\n                  edgeStartAngle = otherNavPoly.centroid.angle(otherEdge.start);\n                  a1 = otherNavPoly.centroid.angle(overlap[0]);\n                  a2 = otherNavPoly.centroid.angle(overlap[1]);\n                  d1 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__utils__[\"b\" /* angleDifference */])(edgeStartAngle, a1);\n                  d2 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__utils__[\"b\" /* angleDifference */])(edgeStartAngle, a2);\n                  if (d1 < d2) {\n                    otherNavPoly.portals.push(new Phaser.Line(p1.x, p1.y, p2.x, p2.y));\n                  } else {\n                    otherNavPoly.portals.push(new Phaser.Line(p2.x, p2.y, p1.x, p1.y));\n                  }\n\n                  // Two convex polygons shouldn't be connected more than once! (Unless\n                  // there are unnecessary vertices...)\n                }\n              } catch (err) {\n                _didIteratorError8 = true;\n                _iteratorError8 = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion8 && _iterator8.return) {\n                    _iterator8.return();\n                  }\n                } finally {\n                  if (_didIteratorError8) {\n                    throw _iteratorError8;\n                  }\n                }\n              }\n            }\n          } catch (err) {\n            _didIteratorError7 = true;\n            _iteratorError7 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion7 && _iterator7.return) {\n                _iterator7.return();\n              }\n            } finally {\n              if (_didIteratorError7) {\n                throw _iteratorError7;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // Check two collinear line segments to see if they overlap by sorting the points.\n    // Algorithm source: http://stackoverflow.com/a/17152247\n\n  }, {\n    key: \"_getSegmentOverlap\",\n    value: function _getSegmentOverlap(line1, line2) {\n      var points = [{ line: line1, point: line1.start }, { line: line1, point: line1.end }, { line: line2, point: line2.start }, { line: line2, point: line2.end }];\n      points.sort(function (a, b) {\n        if (a.point.x < b.point.x) return -1;else if (a.point.x > b.point.x) return 1;else {\n          if (a.point.y < b.point.y) return -1;else if (a.point.y > b.point.y) return 1;else return 0;\n        }\n      });\n      // If the first two points in the array come from the same line, no overlap\n      var noOverlap = points[0].line === points[1].line;\n      // If the two middle points in the array are the same coordinates, then there is a\n      // single point of overlap.\n      var singlePointOverlap = points[1].point.equals(points[2].point);\n      if (noOverlap || singlePointOverlap) return null;else return [points[1].point, points[2].point];\n    }\n\n    /**\r\n     * Project a point onto a polygon in the shortest distance possible.\r\n     * \r\n     * @param {Phaser.Point} point The point to project\r\n     * @param {NavPoly} navPoly The navigation polygon to test against\r\n     * @returns {{point: Phaser.Point, distance: number}}\r\n     * \r\n     * @private\r\n     * @memberof NavMesh\r\n     */\n\n  }, {\n    key: \"_projectPointToPolygon\",\n    value: function _projectPointToPolygon(point, navPoly) {\n      var closestProjection = null;\n      var closestDistance = Number.MAX_VALUE;\n      var _iteratorNormalCompletion9 = true;\n      var _didIteratorError9 = false;\n      var _iteratorError9 = undefined;\n\n      try {\n        for (var _iterator9 = navPoly.edges[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n          var edge = _step9.value;\n\n          var projectedPoint = this._projectPointToEdge(point, edge);\n          var d = point.distance(projectedPoint);\n          if (closestProjection === null || d < closestDistance) {\n            closestDistance = d;\n            closestProjection = projectedPoint;\n          }\n        }\n      } catch (err) {\n        _didIteratorError9 = true;\n        _iteratorError9 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion9 && _iterator9.return) {\n            _iterator9.return();\n          }\n        } finally {\n          if (_didIteratorError9) {\n            throw _iteratorError9;\n          }\n        }\n      }\n\n      return { point: closestProjection, distance: closestDistance };\n    }\n  }, {\n    key: \"_distanceSquared\",\n    value: function _distanceSquared(a, b) {\n      var dx = b.x - a.x;\n      var dy = b.y - a.y;\n      return dx * dx + dy * dy;\n    }\n\n    // Project a point onto a line segment\n    // JS Source: http://stackoverflow.com/questions/849211/shortest-distance-between-a-point-and-a-line-segment\n\n  }, {\n    key: \"_projectPointToEdge\",\n    value: function _projectPointToEdge(point, line) {\n      var a = line.start;\n      var b = line.end;\n      // Consider the parametric equation for the edge's line, p = a + t (b - a). We want to find\n      // where our point lies on the line by solving for t:\n      //  t = [(p-a) . (b-a)] / |b-a|^2\n      var l2 = this._distanceSquared(a, b);\n      var t = ((point.x - a.x) * (b.x - a.x) + (point.y - a.y) * (b.y - a.y)) / l2;\n      // We clamp t from [0,1] to handle points outside the segment vw.\n      t = Phaser.Math.clamp(t, 0, 1);\n      // Project onto the segment\n      var p = new Phaser.Point(a.x + t * (b.x - a.x), a.y + t * (b.y - a.y));\n      return p;\n    }\n\n    /**\r\n     * Enable debug and create graphics overlay (if it hasn't already been created) \r\n     */\n\n  }, {\n    key: \"enableDebug\",\n    value: function enableDebug() {\n      if (!this._debugGraphics) {\n        this._debugGraphics = this.game.add.graphics(0, 0);\n        this._debugGraphics.alpha = 0.5;\n      }\n    }\n\n    /**\r\n     * Disable debug and destroy associated graphics\r\n     */\n\n  }, {\n    key: \"disableDebug\",\n    value: function disableDebug() {\n      if (this._debugGraphics) {\n        this._debugGraphics.destroy();\n        this._debugGraphics = null;\n      }\n    }\n\n    /**\r\n     * Check whether debug is enabled\r\n     * \r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: \"isDebugEnabled\",\n    value: function isDebugEnabled() {\n      return this._debugGraphics !== null;\n    }\n\n    /**\r\n     * Clear the debug overlay\r\n     */\n\n  }, {\n    key: \"debugClear\",\n    value: function debugClear() {\n      if (this._debugGraphics) this._debugGraphics.clear();\n    }\n\n    /**\r\n     * Visualize the polygons in the nav mesh as an overlay on top of the game\r\n     *\r\n     * @param {object} options\r\n     * @param {boolean} [options.drawCentroid=true] For each polygon, show the approx centroid\r\n     * @param {boolean} [options.drawBounds=false] For each polygon, show the bounding radius\r\n     * @param {boolean} [options.drawNeighbors=true] For each polygon, show the connections to\r\n     * neighbors\r\n     * @param {boolean} [options.drawPortals=true] For each polygon, show the portal edges\r\n     */\n\n  }, {\n    key: \"debugDrawMesh\",\n    value: function debugDrawMesh() {\n      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref4$drawCentroid = _ref4.drawCentroid,\n          drawCentroid = _ref4$drawCentroid === undefined ? true : _ref4$drawCentroid,\n          _ref4$drawBounds = _ref4.drawBounds,\n          drawBounds = _ref4$drawBounds === undefined ? false : _ref4$drawBounds,\n          _ref4$drawNeighbors = _ref4.drawNeighbors,\n          drawNeighbors = _ref4$drawNeighbors === undefined ? true : _ref4$drawNeighbors,\n          _ref4$drawPortals = _ref4.drawPortals,\n          drawPortals = _ref4$drawPortals === undefined ? true : _ref4$drawPortals;\n\n      if (!this._debugGraphics) this.enableDebug();\n      // Visualize the navigation mesh\n      var _iteratorNormalCompletion10 = true;\n      var _didIteratorError10 = false;\n      var _iteratorError10 = undefined;\n\n      try {\n        for (var _iterator10 = this._navPolygons[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n          var navPoly = _step10.value;\n\n          navPoly.draw(this._debugGraphics, drawCentroid, drawBounds, drawNeighbors, drawPortals);\n        }\n      } catch (err) {\n        _didIteratorError10 = true;\n        _iteratorError10 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion10 && _iterator10.return) {\n            _iterator10.return();\n          }\n        } finally {\n          if (_didIteratorError10) {\n            throw _iteratorError10;\n          }\n        }\n      }\n    }\n\n    /**\r\n     * Visualize a path (array of points) on the debug graphics overlay\r\n     * \r\n     * @param {Phaser.Point[]} path \r\n     * @param {number} [color=0x00FF00] \r\n     * @param {number} [thickness=10] \r\n     */\n\n  }, {\n    key: \"debugDrawPath\",\n    value: function debugDrawPath(path) {\n      var color = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0x00ff00;\n      var thickness = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;\n\n      if (!this._debugGraphics) this.enableDebug();\n      if (path.length) {\n        // Draw line for path\n        this._debugGraphics.lineStyle(thickness, color);\n        this._debugGraphics.drawShape(new (Function.prototype.bind.apply(Phaser.Polygon, [null].concat(_toConsumableArray(path))))());\n        this._debugGraphics.beginFill(color);\n        // Draw circle at start and end of path\n        var d = 0.5 * thickness;\n        this._debugGraphics.drawEllipse(path[0].x, path[0].y, d, d);\n        var lastPoint = path[path.length - 1];\n        this._debugGraphics.drawEllipse(lastPoint.x, lastPoint.y, d, d);\n        this._debugGraphics.endFill();\n      }\n    }\n  }]);\n\n  return NavMesh;\n}();\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (NavMesh);\n\n/***/ }),\n/* 7 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// Debug color palette\nvar palette = [0x00a0b0, 0x6a4a3c, 0xcc333f, 0xeb6841, 0xedc951];\n\n/**\r\n * A class that represents a navigable polygon in a navmesh. It is build from a Phaser.Polygon. It\r\n * has a drawing function to help visualize it's features:\r\n *  - polygon\r\n *  - neighbors - any navpolys that can be reached from this navpoly\r\n *  - portals - overlapping edges between neighbors\r\n *  - centroid - not a true centroid, just an approximation.\r\n *  - boundingRadius - the radius of a circle at the centroid that fits all the points of the poly \r\n * \r\n * It implements the properties and fields that javascript-astar needs - weight, toString, isWall\r\n * and getCost. See GPS test from astar repo for structure: \r\n * https://github.com/bgrins/javascript-astar/blob/master/test/tests.js\r\n *\r\n * @class NavPoly\r\n * @private\r\n */\n\nvar NavPoly = function () {\n  /**\r\n   * Creates an instance of NavPoly.\r\n   * @param {Phaser.Game} game \r\n   * @param {number} id \r\n   * @param {Phaser.Polygon} polygon \r\n   * \r\n   * @memberof NavPoly\r\n   */\n  function NavPoly(game, id, polygon) {\n    _classCallCheck(this, NavPoly);\n\n    this.game = game;\n    this.id = id;\n    this.polygon = polygon;\n    this.edges = this._calculateEdges();\n    this.neighbors = [];\n    this.portals = [];\n    this.centroid = this._calculateCentroid();\n    this.boundingRadius = this._calculateRadius();\n\n    this.weight = 1; // jsastar property\n\n    var i = this.id % palette.length;\n    this._color = palette[i];\n  }\n\n  _createClass(NavPoly, [{\n    key: \"contains\",\n    value: function contains(point) {\n      // Phaser's polygon check doesn't handle when a point is on one of the edges of the line. Note:\n      // check numerical stability here. It would also be good to optimize this for different shapes.\n      return this.polygon.contains(point.x, point.y) || this._isPointOnEdge(point);\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.game = null;\n      this.neighbors = [];\n      this.portals = [];\n    }\n\n    // jsastar methods\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"NavPoly(id: \" + this.id + \" at: \" + this.centroid + \")\";\n    }\n  }, {\n    key: \"isWall\",\n    value: function isWall() {\n      return this.weight === 0;\n    }\n  }, {\n    key: \"centroidDistance\",\n    value: function centroidDistance(navPolygon) {\n      return this.centroid.distance(navPolygon.centroid);\n    }\n  }, {\n    key: \"getCost\",\n    value: function getCost(navPolygon) {\n      return this.centroidDistance(navPolygon);\n    }\n  }, {\n    key: \"_calculateEdges\",\n    value: function _calculateEdges() {\n      var points = this.polygon.points;\n      var edges = [];\n      for (var i = 1; i < points.length; i++) {\n        var p1 = points[i - 1];\n        var p2 = points[i];\n        edges.push(new Phaser.Line(p1.x, p1.y, p2.x, p2.y));\n      }\n      var first = points[0];\n      var last = points[points.length - 1];\n      edges.push(new Phaser.Line(first.x, first.y, last.x, last.y));\n      return edges;\n    }\n  }, {\n    key: \"_calculateCentroid\",\n    value: function _calculateCentroid() {\n      // NOTE: this is not actually the centroid, it's the average of the vertices - not the same\n      // thing!\n      var centroid = new Phaser.Point(0, 0);\n      var length = this.polygon.points.length;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this.polygon.points[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var point = _step.value;\n\n          centroid.add(point.x, point.y);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      centroid.divide(length, length);\n      return centroid;\n    }\n  }, {\n    key: \"_calculateRadius\",\n    value: function _calculateRadius() {\n      var boundingRadius = 0;\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = this.polygon.points[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var point = _step2.value;\n\n          var d = this.centroid.distance(point);\n          if (d > boundingRadius) boundingRadius = d;\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return boundingRadius;\n    }\n  }, {\n    key: \"_isPointOnEdge\",\n    value: function _isPointOnEdge(point) {\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = this.edges[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var edge = _step3.value;\n\n          if (edge.pointOnSegment(point.x, point.y)) return true;\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      return false;\n    }\n\n    /**\r\n     * Draw the polygon to given graphics object\r\n     * \r\n     * @param {Phaser.Graphics} graphics \r\n     * @param {boolean} [drawCentroid=true] Show the approx centroid\r\n     * @param {boolean} [drawBounds=false] Show the bounding radius\r\n     * @param {boolean} [drawNeighbors=true] Show the connections to neighbors\r\n     * @param {boolean} [drawPortals=true] Show the portal edges\r\n     * \r\n     * @memberof NavPoly\r\n     */\n\n  }, {\n    key: \"draw\",\n    value: function draw(graphics) {\n      var drawCentroid = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var drawBounds = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var drawNeighbors = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n      var drawPortals = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n\n      graphics.lineWidth = 0;\n      graphics.beginFill(this._color);\n      graphics.drawPolygon(this.polygon);\n      graphics.endFill();\n\n      if (drawCentroid) {\n        graphics.beginFill(0x000000);\n        graphics.drawEllipse(this.centroid.x, this.centroid.y, 4, 4);\n        graphics.endFill();\n      }\n\n      if (drawBounds) {\n        graphics.lineStyle(1, 0xffffff);\n        var r = this.boundingRadius;\n        graphics.drawEllipse(this.centroid.x, this.centroid.y, r, r);\n      }\n\n      if (drawNeighbors) {\n        graphics.lineStyle(2, 0x000000);\n        var _iteratorNormalCompletion4 = true;\n        var _didIteratorError4 = false;\n        var _iteratorError4 = undefined;\n\n        try {\n          for (var _iterator4 = this.neighbors[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n            var n = _step4.value;\n\n            graphics.moveTo(this.centroid.x, this.centroid.y);\n            graphics.lineTo(n.centroid.x, n.centroid.y);\n          }\n        } catch (err) {\n          _didIteratorError4 = true;\n          _iteratorError4 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion4 && _iterator4.return) {\n              _iterator4.return();\n            }\n          } finally {\n            if (_didIteratorError4) {\n              throw _iteratorError4;\n            }\n          }\n        }\n      }\n\n      if (drawPortals) {\n        graphics.lineStyle(10, 0x000000);\n        var _iteratorNormalCompletion5 = true;\n        var _didIteratorError5 = false;\n        var _iteratorError5 = undefined;\n\n        try {\n          for (var _iterator5 = this.portals[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n            var p = _step5.value;\n\n            graphics.moveTo(p.start.x, p.start.y);\n            graphics.lineTo(p.end.x, p.end.y);\n          }\n        } catch (err) {\n          _didIteratorError5 = true;\n          _iteratorError5 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion5 && _iterator5.return) {\n              _iterator5.return();\n            }\n          } finally {\n            if (_didIteratorError5) {\n              throw _iteratorError5;\n            }\n          }\n        }\n      }\n    }\n  }]);\n\n  return NavPoly;\n}();\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (NavPoly);\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// phaser-navmesh.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 1e1f6e5e13802be39203","/**\r\n * Twice the area of the triangle formed by a, b and c\r\n * @private\r\n */\r\nexport function triarea2(a, b, c) {\r\n  const ax = b.x - a.x;\r\n  const ay = b.y - a.y;\r\n  const bx = c.x - a.x;\r\n  const by = c.y - a.y;\r\n  return bx * ay - ax * by;\r\n}\r\n\r\n/**\r\n * @private\r\n */\r\nexport function almostEqual(value1, value2, errorMargin = 0.0001) {\r\n  if (Math.abs(value1 - value2) <= errorMargin) return true;\r\n  else return false;\r\n}\r\n\r\n/**\r\n * https://gist.github.com/Aaronduino/4068b058f8dbc34b4d3a9eedc8b2cbe0\r\n * @private\r\n */\r\nexport function angleDifference(x, y) {\r\n  let a = x - y;\r\n  const i = a + Math.PI;\r\n  const j = Math.PI * 2;\r\n  a = i - Math.floor(i / j) * j; // (a+180) % 360; this ensures the correct sign\r\n  a -= Math.PI;\r\n  return a;\r\n}\r\n\r\n/**\r\n * @private\r\n */\r\nexport function areCollinear(line1, line2, errorMargin = 0.0001) {\r\n  // Figure out if the two lines are equal by looking at the area of the triangle formed\r\n  // by their points\r\n  const area1 = triarea2(line1.start, line1.end, line2.start);\r\n  const area2 = triarea2(line1.start, line1.end, line2.end);\r\n  if (almostEqual(area1, 0, errorMargin) && almostEqual(area2, 0, errorMargin)) {\r\n    return true;\r\n  } else return false;\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./utils.js","// javascript-astar 0.4.2\r\n// http://github.com/bgrins/javascript-astar\r\n// Freely distributable under the MIT License.\r\n// Implements the astar search algorithm in javascript using a Binary Heap.\r\n// Includes Binary Heap (with modifications) from Marijn Haverbeke.\r\n// http://eloquentjavascript.net/appendix2.html\r\n(function(definition) {\r\n  /* global module, define */\r\n  if (typeof module === 'object' && typeof module.exports === 'object') {\r\n    module.exports = definition();\r\n  } else if (typeof define === 'function' && define.amd) {\r\n    define([], definition);\r\n  } else {\r\n    var exports = definition();\r\n    window.astar = exports.astar;\r\n    window.Graph = exports.Graph;\r\n  }\r\n})(function() {\r\n\r\nfunction pathTo(node) {\r\n  var curr = node;\r\n  var path = [];\r\n  while (curr.parent) {\r\n    path.unshift(curr);\r\n    curr = curr.parent;\r\n  }\r\n  return path;\r\n}\r\n\r\nfunction getHeap() {\r\n  return new BinaryHeap(function(node) {\r\n    return node.f;\r\n  });\r\n}\r\n\r\nvar astar = {\r\n  /**\r\n  * Perform an A* Search on a graph given a start and end node.\r\n  * @param {Graph} graph\r\n  * @param {GridNode} start\r\n  * @param {GridNode} end\r\n  * @param {Object} [options]\r\n  * @param {bool} [options.closest] Specifies whether to return the\r\n             path to the closest node if the target is unreachable.\r\n  * @param {Function} [options.heuristic] Heuristic function (see\r\n  *          astar.heuristics).\r\n  */\r\n  search: function(graph, start, end, options) {\r\n    graph.cleanDirty();\r\n    options = options || {};\r\n    var heuristic = options.heuristic || astar.heuristics.manhattan;\r\n    var closest = options.closest || false;\r\n\r\n    var openHeap = getHeap();\r\n    var closestNode = start; // set the start node to be the closest if required\r\n\r\n    start.h = heuristic(start, end);\r\n    graph.markDirty(start);\r\n\r\n    openHeap.push(start);\r\n\r\n    while (openHeap.size() > 0) {\r\n\r\n      // Grab the lowest f(x) to process next.  Heap keeps this sorted for us.\r\n      var currentNode = openHeap.pop();\r\n\r\n      // End case -- result has been found, return the traced path.\r\n      if (currentNode === end) {\r\n        return pathTo(currentNode);\r\n      }\r\n\r\n      // Normal case -- move currentNode from open to closed, process each of its neighbors.\r\n      currentNode.closed = true;\r\n\r\n      // Find all neighbors for the current node.\r\n      var neighbors = graph.neighbors(currentNode);\r\n\r\n      for (var i = 0, il = neighbors.length; i < il; ++i) {\r\n        var neighbor = neighbors[i];\r\n\r\n        if (neighbor.closed || neighbor.isWall()) {\r\n          // Not a valid node to process, skip to next neighbor.\r\n          continue;\r\n        }\r\n\r\n        // The g score is the shortest distance from start to current node.\r\n        // We need to check if the path we have arrived at this neighbor is the shortest one we have seen yet.\r\n        var gScore = currentNode.g + neighbor.getCost(currentNode);\r\n        var beenVisited = neighbor.visited;\r\n\r\n        if (!beenVisited || gScore < neighbor.g) {\r\n\r\n          // Found an optimal (so far) path to this node.  Take score for node to see how good it is.\r\n          neighbor.visited = true;\r\n          neighbor.parent = currentNode;\r\n          neighbor.h = neighbor.h || heuristic(neighbor, end);\r\n          neighbor.g = gScore;\r\n          neighbor.f = neighbor.g + neighbor.h;\r\n          graph.markDirty(neighbor);\r\n          if (closest) {\r\n            // If the neighbour is closer than the current closestNode or if it's equally close but has\r\n            // a cheaper path than the current closest node then it becomes the closest node\r\n            if (neighbor.h < closestNode.h || (neighbor.h === closestNode.h && neighbor.g < closestNode.g)) {\r\n              closestNode = neighbor;\r\n            }\r\n          }\r\n\r\n          if (!beenVisited) {\r\n            // Pushing to heap will put it in proper place based on the 'f' value.\r\n            openHeap.push(neighbor);\r\n          } else {\r\n            // Already seen the node, but since it has been rescored we need to reorder it in the heap\r\n            openHeap.rescoreElement(neighbor);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (closest) {\r\n      return pathTo(closestNode);\r\n    }\r\n\r\n    // No result was found - empty array signifies failure to find path.\r\n    return [];\r\n  },\r\n  // See list of heuristics: http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html\r\n  heuristics: {\r\n    manhattan: function(pos0, pos1) {\r\n      var d1 = Math.abs(pos1.x - pos0.x);\r\n      var d2 = Math.abs(pos1.y - pos0.y);\r\n      return d1 + d2;\r\n    },\r\n    diagonal: function(pos0, pos1) {\r\n      var D = 1;\r\n      var D2 = Math.sqrt(2);\r\n      var d1 = Math.abs(pos1.x - pos0.x);\r\n      var d2 = Math.abs(pos1.y - pos0.y);\r\n      return (D * (d1 + d2)) + ((D2 - (2 * D)) * Math.min(d1, d2));\r\n    }\r\n  },\r\n  cleanNode: function(node) {\r\n    node.f = 0;\r\n    node.g = 0;\r\n    node.h = 0;\r\n    node.visited = false;\r\n    node.closed = false;\r\n    node.parent = null;\r\n  }\r\n};\r\n\r\n/**\r\n * A graph memory structure\r\n * @param {Array} gridIn 2D array of input weights\r\n * @param {Object} [options]\r\n * @param {bool} [options.diagonal] Specifies whether diagonal moves are allowed\r\n */\r\nfunction Graph(gridIn, options) {\r\n  options = options || {};\r\n  this.nodes = [];\r\n  this.diagonal = !!options.diagonal;\r\n  this.grid = [];\r\n  for (var x = 0; x < gridIn.length; x++) {\r\n    this.grid[x] = [];\r\n\r\n    for (var y = 0, row = gridIn[x]; y < row.length; y++) {\r\n      var node = new GridNode(x, y, row[y]);\r\n      this.grid[x][y] = node;\r\n      this.nodes.push(node);\r\n    }\r\n  }\r\n  this.init();\r\n}\r\n\r\nGraph.prototype.init = function() {\r\n  this.dirtyNodes = [];\r\n  for (var i = 0; i < this.nodes.length; i++) {\r\n    astar.cleanNode(this.nodes[i]);\r\n  }\r\n};\r\n\r\nGraph.prototype.cleanDirty = function() {\r\n  for (var i = 0; i < this.dirtyNodes.length; i++) {\r\n    astar.cleanNode(this.dirtyNodes[i]);\r\n  }\r\n  this.dirtyNodes = [];\r\n};\r\n\r\nGraph.prototype.markDirty = function(node) {\r\n  this.dirtyNodes.push(node);\r\n};\r\n\r\nGraph.prototype.neighbors = function(node) {\r\n  var ret = [];\r\n  var x = node.x;\r\n  var y = node.y;\r\n  var grid = this.grid;\r\n\r\n  // West\r\n  if (grid[x - 1] && grid[x - 1][y]) {\r\n    ret.push(grid[x - 1][y]);\r\n  }\r\n\r\n  // East\r\n  if (grid[x + 1] && grid[x + 1][y]) {\r\n    ret.push(grid[x + 1][y]);\r\n  }\r\n\r\n  // South\r\n  if (grid[x] && grid[x][y - 1]) {\r\n    ret.push(grid[x][y - 1]);\r\n  }\r\n\r\n  // North\r\n  if (grid[x] && grid[x][y + 1]) {\r\n    ret.push(grid[x][y + 1]);\r\n  }\r\n\r\n  if (this.diagonal) {\r\n    // Southwest\r\n    if (grid[x - 1] && grid[x - 1][y - 1]) {\r\n      ret.push(grid[x - 1][y - 1]);\r\n    }\r\n\r\n    // Southeast\r\n    if (grid[x + 1] && grid[x + 1][y - 1]) {\r\n      ret.push(grid[x + 1][y - 1]);\r\n    }\r\n\r\n    // Northwest\r\n    if (grid[x - 1] && grid[x - 1][y + 1]) {\r\n      ret.push(grid[x - 1][y + 1]);\r\n    }\r\n\r\n    // Northeast\r\n    if (grid[x + 1] && grid[x + 1][y + 1]) {\r\n      ret.push(grid[x + 1][y + 1]);\r\n    }\r\n  }\r\n\r\n  return ret;\r\n};\r\n\r\nGraph.prototype.toString = function() {\r\n  var graphString = [];\r\n  var nodes = this.grid;\r\n  for (var x = 0; x < nodes.length; x++) {\r\n    var rowDebug = [];\r\n    var row = nodes[x];\r\n    for (var y = 0; y < row.length; y++) {\r\n      rowDebug.push(row[y].weight);\r\n    }\r\n    graphString.push(rowDebug.join(\" \"));\r\n  }\r\n  return graphString.join(\"\\n\");\r\n};\r\n\r\nfunction GridNode(x, y, weight) {\r\n  this.x = x;\r\n  this.y = y;\r\n  this.weight = weight;\r\n}\r\n\r\nGridNode.prototype.toString = function() {\r\n  return \"[\" + this.x + \" \" + this.y + \"]\";\r\n};\r\n\r\nGridNode.prototype.getCost = function(fromNeighbor) {\r\n  // Take diagonal weight into consideration.\r\n  if (fromNeighbor && fromNeighbor.x != this.x && fromNeighbor.y != this.y) {\r\n    return this.weight * 1.41421;\r\n  }\r\n  return this.weight;\r\n};\r\n\r\nGridNode.prototype.isWall = function() {\r\n  return this.weight === 0;\r\n};\r\n\r\nfunction BinaryHeap(scoreFunction) {\r\n  this.content = [];\r\n  this.scoreFunction = scoreFunction;\r\n}\r\n\r\nBinaryHeap.prototype = {\r\n  push: function(element) {\r\n    // Add the new element to the end of the array.\r\n    this.content.push(element);\r\n\r\n    // Allow it to sink down.\r\n    this.sinkDown(this.content.length - 1);\r\n  },\r\n  pop: function() {\r\n    // Store the first element so we can return it later.\r\n    var result = this.content[0];\r\n    // Get the element at the end of the array.\r\n    var end = this.content.pop();\r\n    // If there are any elements left, put the end element at the\r\n    // start, and let it bubble up.\r\n    if (this.content.length > 0) {\r\n      this.content[0] = end;\r\n      this.bubbleUp(0);\r\n    }\r\n    return result;\r\n  },\r\n  remove: function(node) {\r\n    var i = this.content.indexOf(node);\r\n\r\n    // When it is found, the process seen in 'pop' is repeated\r\n    // to fill up the hole.\r\n    var end = this.content.pop();\r\n\r\n    if (i !== this.content.length - 1) {\r\n      this.content[i] = end;\r\n\r\n      if (this.scoreFunction(end) < this.scoreFunction(node)) {\r\n        this.sinkDown(i);\r\n      } else {\r\n        this.bubbleUp(i);\r\n      }\r\n    }\r\n  },\r\n  size: function() {\r\n    return this.content.length;\r\n  },\r\n  rescoreElement: function(node) {\r\n    this.sinkDown(this.content.indexOf(node));\r\n  },\r\n  sinkDown: function(n) {\r\n    // Fetch the element that has to be sunk.\r\n    var element = this.content[n];\r\n\r\n    // When at 0, an element can not sink any further.\r\n    while (n > 0) {\r\n\r\n      // Compute the parent element's index, and fetch it.\r\n      var parentN = ((n + 1) >> 1) - 1;\r\n      var parent = this.content[parentN];\r\n      // Swap the elements if the parent is greater.\r\n      if (this.scoreFunction(element) < this.scoreFunction(parent)) {\r\n        this.content[parentN] = element;\r\n        this.content[n] = parent;\r\n        // Update 'n' to continue at the new position.\r\n        n = parentN;\r\n      }\r\n      // Found a parent that is less, no need to sink any further.\r\n      else {\r\n        break;\r\n      }\r\n    }\r\n  },\r\n  bubbleUp: function(n) {\r\n    // Look up the target element and its score.\r\n    var length = this.content.length;\r\n    var element = this.content[n];\r\n    var elemScore = this.scoreFunction(element);\r\n\r\n    while (true) {\r\n      // Compute the indices of the child elements.\r\n      var child2N = (n + 1) << 1;\r\n      var child1N = child2N - 1;\r\n      // This is used to store the new position of the element, if any.\r\n      var swap = null;\r\n      var child1Score;\r\n      // If the first child exists (is inside the array)...\r\n      if (child1N < length) {\r\n        // Look it up and compute its score.\r\n        var child1 = this.content[child1N];\r\n        child1Score = this.scoreFunction(child1);\r\n\r\n        // If the score is less than our element's, we need to swap.\r\n        if (child1Score < elemScore) {\r\n          swap = child1N;\r\n        }\r\n      }\r\n\r\n      // Do the same checks for the other child.\r\n      if (child2N < length) {\r\n        var child2 = this.content[child2N];\r\n        var child2Score = this.scoreFunction(child2);\r\n        if (child2Score < (swap === null ? elemScore : child1Score)) {\r\n          swap = child2N;\r\n        }\r\n      }\r\n\r\n      // If the element needs to be moved, swap it, and continue.\r\n      if (swap !== null) {\r\n        this.content[n] = this.content[swap];\r\n        this.content[swap] = element;\r\n        n = swap;\r\n      }\r\n      // Otherwise, we are done.\r\n      else {\r\n        break;\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nreturn {\r\n  astar: astar,\r\n  Graph: Graph\r\n};\r\n\r\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// E:/Github/navmesh-phaser-plugin/~/javascript-astar/astar.js\n// module id = 1\n// module chunks = 0 1","// const triangulate = require(\"./triangulate\");\r\nimport NavMesh from \"./nav-mesh\";\r\n\r\n/**\r\n * This plugin can create navigation meshes for use in Phaser. The navmeshes can be constructed from\r\n * convex polygons embedded in a Tiled map. Instantiate this using game.plugins.add(NavMeshPlugin).\r\n *\r\n * @param {Phaser.Game} game\r\n * @param {Phaser.PluginManager} manager\r\n */\r\nexport default class NavMeshPlugin extends Phaser.Plugin {\r\n  constructor(game, manager) {\r\n    super(game, manager);\r\n    this._navMeshes = [];\r\n  }\r\n\r\n  /**\r\n   * Load a navmesh from Tiled and switch it to be the current navmesh. Currently assumes that the\r\n   * polygons are squares!\r\n   * \r\n   * @param {Phaser.Tilemap} tilemap The tilemap that contains polygons under an object layer\r\n   * @param {string} objectKey The name of the object layer in the tilemap\r\n   * @param {number} [meshShrinkAmount=0] The amount (in pixels) that the navmesh has been\r\n   * shrunk around obstacles (a.k.a the amount obstacles have been expanded)\r\n   * \r\n   * @memberof NavMeshPlugin\r\n   */\r\n  buildMeshFromTiled(tilemap, objectKey, meshShrinkAmount = 0) {\r\n    if (!tilemap.objects[objectKey]) {\r\n      console.warn(\r\n        `NavMeshPlugin: The given tilemap has no object layer with the name \"${objectKey}\"`\r\n      );\r\n    } else if (tilemap.objects[objectKey].length === 0) {\r\n      console.warn(\r\n        `NavMeshPlugin: The \"${objectKey}\" object layer in the Tilemap has 0 objects in it`\r\n      );\r\n    }\r\n    // Load up the object layer\r\n    const rects = tilemap.objects[objectKey] || [];\r\n    // Loop over the objects and construct a polygon\r\n    const polygons = [];\r\n    for (const r of rects) {\r\n      const top = r.y;\r\n      const bottom = r.y + r.height;\r\n      const left = r.x;\r\n      const right = r.x + r.width;\r\n      const poly = new Phaser.Polygon(left, top, left, bottom, right, bottom, right, top);\r\n      polygons.push(poly);\r\n    }\r\n    // Build the navmesh\r\n    const mesh = new NavMesh(this.game, polygons, meshShrinkAmount);\r\n    this._navMeshes.push(mesh);\r\n    return mesh;\r\n  }\r\n\r\n  destroy() {\r\n    for (const mesh of this._navMeshes) mesh.destroy();\r\n    this._navMeshes = [];\r\n    super.destroy();\r\n  }\r\n\r\n  // /**\r\n  //  * Build a navmesh from an array of convex polygons. This currently tesselates the polygons into\r\n  //  * triangles. They aren't as efficient or as well designed as ones made by hand in Tiled.\r\n  //  *\r\n  //  * @param {string} levelName The key to use to store the navmesh in the plugin\r\n  //  * @param {[]} hulls An array of convex polygons describing the obstacles in the\r\n  //  * level. See lighting-plugin/hull-from-tiles.\r\n  //  *\r\n  //  * @memberof NavMeshPlugin\r\n  //  */\r\n  // buildMesh(levelName, hulls) {\r\n  //     const contours = this._buildContours(hulls);\r\n  //     // Get an array of triangulated vertices\r\n  //     const triangles = triangulate(contours, false); // Counter-clockwise ordering!\r\n  //     const polygons = [];\r\n  //     for (let i = 0; i < triangles.length; i += 6) {\r\n  //         const poly = new Phaser.Polygon(\r\n  //             // These should be in counter-clockwise order from triangulate\r\n  //             triangles[i + 0], triangles[i + 1],\r\n  //             triangles[i + 2], triangles[i + 3],\r\n  //             triangles[i + 4], triangles[i + 5]\r\n  //         );\r\n  //         polygons.push(poly);\r\n  //     }\r\n  //     const navMesh = new NavMesh(this.game, polygons);\r\n  //     this._navMeshes[levelName] = navMesh;\r\n  //     this._currentNavMesh = navMesh;\r\n  // }\r\n\r\n  // /**\r\n  //  * @param {[]} hulls\r\n  //  * @returns\r\n  //  *\r\n  //  * @memberof NavMeshPlugin\r\n  //  */\r\n  // _buildContours(hulls) {\r\n  //     const w = this.game.width;\r\n  //     const h = this.game.height;\r\n  //     // Start the contours\r\n  //     const contours = [\r\n  //         // Full screen - counter clockwise\r\n  //         Float32Array.of(0,0, 0,h, w,h, w,0)\r\n  //     ];\r\n  //     // For each convex hull add the contour\r\n  //     for (const hull of hulls) {\r\n  //         const contour = [];\r\n  //         for (const lineInfo of hull) {\r\n  //             contour.push(lineInfo.line.start.x, lineInfo.line.start.y);\r\n  //         }\r\n  //         contours.push(Float32Array.from(contour));\r\n  //     }\r\n  //     return contours;\r\n  // }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./nav-mesh-plugin.js","// Mostly sourced from PatrolJS at the moment. TODO: come back and reimplement this as an incomplete\r\n// funnel algorithm so astar checks can be more accurate.\r\n\r\nimport { triarea2 } from \"./utils\";\r\n\r\n/**\r\n * @private\r\n */\r\nclass Channel {\r\n  constructor() {\r\n    this.portals = [];\r\n  }\r\n\r\n  /**\r\n   * @param {Phaser.Point} p1 \r\n   * @param {Phaser.Point} p2 \r\n   * \r\n   * @memberof Channel\r\n   */\r\n  push(p1, p2 = null) {\r\n    if (p2 === null) p2 = p1;\r\n    this.portals.push({\r\n      left: p1,\r\n      right: p2\r\n    });\r\n  }\r\n\r\n  stringPull() {\r\n    var portals = this.portals;\r\n    var pts = [];\r\n    // Init scan state\r\n    var portalApex, portalLeft, portalRight;\r\n    var apexIndex = 0,\r\n      leftIndex = 0,\r\n      rightIndex = 0;\r\n\r\n    portalApex = portals[0].left;\r\n    portalLeft = portals[0].left;\r\n    portalRight = portals[0].right;\r\n\r\n    // Add start point.\r\n    pts.push(portalApex);\r\n\r\n    for (var i = 1; i < portals.length; i++) {\r\n      // Find the next portal vertices\r\n      var left = portals[i].left;\r\n      var right = portals[i].right;\r\n\r\n      // Update right vertex.\r\n      if (triarea2(portalApex, portalRight, right) <= 0.0) {\r\n        if (portalApex.equals(portalRight) || triarea2(portalApex, portalLeft, right) > 0.0) {\r\n          // Tighten the funnel.\r\n          portalRight = right;\r\n          rightIndex = i;\r\n        } else {\r\n          // Right vertex just crossed over the left vertex, so the left vertex should\r\n          // now be part of the path.\r\n          pts.push(portalLeft);\r\n\r\n          // Restart scan from portal left point.\r\n\r\n          // Make current left the new apex.\r\n          portalApex = portalLeft;\r\n          apexIndex = leftIndex;\r\n          // Reset portal\r\n          portalLeft = portalApex;\r\n          portalRight = portalApex;\r\n          leftIndex = apexIndex;\r\n          rightIndex = apexIndex;\r\n          // Restart scan\r\n          i = apexIndex;\r\n          continue;\r\n        }\r\n      }\r\n\r\n      // Update left vertex.\r\n      if (triarea2(portalApex, portalLeft, left) >= 0.0) {\r\n        if (portalApex.equals(portalLeft) || triarea2(portalApex, portalRight, left) < 0.0) {\r\n          // Tighten the funnel.\r\n          portalLeft = left;\r\n          leftIndex = i;\r\n        } else {\r\n          // Left vertex just crossed over the right vertex, so the right vertex should\r\n          // now be part of the path\r\n          pts.push(portalRight);\r\n\r\n          // Restart scan from portal right point.\r\n\r\n          // Make current right the new apex.\r\n          portalApex = portalRight;\r\n          apexIndex = rightIndex;\r\n          // Reset portal\r\n          portalLeft = portalApex;\r\n          portalRight = portalApex;\r\n          leftIndex = apexIndex;\r\n          rightIndex = apexIndex;\r\n          // Restart scan\r\n          i = apexIndex;\r\n          continue;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (pts.length === 0 || !pts[pts.length - 1].equals(portals[portals.length - 1].left)) {\r\n      // Append last point to path.\r\n      pts.push(portals[portals.length - 1].left);\r\n    }\r\n\r\n    this.path = pts;\r\n    return pts;\r\n  }\r\n}\r\n\r\nexport default Channel;\r\n\n\n\n// WEBPACK FOOTER //\n// ./channel.js","// Fix for webpack not exporting ES6 module default properly when using global mode of UMD. It ends\r\n// up with someone having to do \"PhaserNavmesh.default\" instead of \"PhaserNavmesh\"\r\nmodule.exports = require(\"./nav-mesh-plugin\").default;\r\n\n\n\n// WEBPACK FOOTER //\n// ./index.js","import jsastar from \"javascript-astar\";\r\n\r\n/**\r\n * Graph for javascript-astar. It implements the functionality for astar. See GPS test from astar\r\n * repo for structure: https://github.com/bgrins/javascript-astar/blob/master/test/tests.js\r\n *\r\n * @class NavGraph \r\n * @private\r\n */\r\nclass NavGraph {\r\n  constructor(navPolygons) {\r\n    this.nodes = navPolygons;\r\n    this.init();\r\n  }\r\n\r\n  neighbors(navPolygon) {\r\n    return navPolygon.neighbors;\r\n  }\r\n\r\n  navHeuristic(navPolygon1, navPolygon2) {\r\n    return navPolygon1.centroidDistance(navPolygon2);\r\n  }\r\n\r\n  destroy() {\r\n    this.cleanDirty();\r\n    this.nodes = [];\r\n  }\r\n}\r\n\r\nNavGraph.prototype.init = jsastar.Graph.prototype.init;\r\nNavGraph.prototype.cleanDirty = jsastar.Graph.prototype.cleanDirty;\r\nNavGraph.prototype.markDirty = jsastar.Graph.prototype.markDirty;\r\n\r\nexport default NavGraph;\r\n\n\n\n// WEBPACK FOOTER //\n// ./nav-graph.js","import jsastar from \"javascript-astar\";\r\nimport NavPoly from \"./nav-poly\";\r\nimport NavGraph from \"./nav-graph\";\r\nimport Channel from \"./channel\";\r\nimport { angleDifference, areCollinear } from \"./utils\";\r\n\r\n/**\r\n * The workhorse that represents a navigation mesh built from a series of polygons. Once built, the\r\n * mesh can be asked for a path from one point to another point. It has debug methods for \r\n * visualizing paths and visualizing the individual polygons. Some internal terminology usage:\r\n * \r\n * - neighbor: a polygon that shares part of an edge with another polygon\r\n * - portal: when two neighbor's have edges that overlap, the portal is the overlapping line segment\r\n * - channel: the path of polygons from starting point to end point\r\n * - pull the string: run the funnel algorithm on the channel so that the path hugs the edges of the\r\n *   channel. Equivalent to having a string snaking through a hallway and then pulling it taut.\r\n */\r\nclass NavMesh {\r\n  /**\r\n   * Creates an instance of NavMesh.\r\n   * \r\n   * @param {Phaser.Game} game\r\n   * @param {Phaser.Polygon[]} polygons\r\n   * @param {number} [meshShrinkAmount=0] The amount (in pixels) that the navmesh has been\r\n   * shrunk around obstacles (a.k.a the amount obstacles have been expanded)\r\n   */\r\n  constructor(game, polygons, meshShrinkAmount = 0) {\r\n    this.game = game;\r\n    this._debugGraphics = null;\r\n    this._meshShrinkAmount = meshShrinkAmount;\r\n\r\n    // Construct NavPoly instances for each polygon\r\n    this._navPolygons = [];\r\n    for (const [i, polygon] of polygons.entries()) {\r\n      this._navPolygons.push(new NavPoly(game, i, polygon));\r\n    }\r\n\r\n    this._calculateNeighbors();\r\n\r\n    // Astar graph of connections between polygons\r\n    this._graph = new NavGraph(this._navPolygons);\r\n  }\r\n\r\n  /**\r\n   * Cleanup method to remove references so that navmeshes don't hang around from state to state.\r\n   * You don't have to invoke this directly. If you call destroy on the plugin, it will destroy\r\n   * all navmeshes that have been created. \r\n   * \r\n   * @memberof NavMesh\r\n   */\r\n  destroy() {\r\n    this._graph.destroy();\r\n    for (const poly of this._navPolygons) poly.destroy();\r\n    this._navPolygons = [];\r\n    this.game = null;\r\n    this.disableDebug();\r\n  }\r\n\r\n  /**\r\n   * Find a path from the start point to the end point using this nav mesh.\r\n   *\r\n   * @param {Phaser.Point} startPoint\r\n   * @param {Phaser.Point} endPoint\r\n   * @param {object} [drawOptions={}] Options for controlling debug drawing\r\n   * @param {boolean} [drawOptions.drawPolyPath=false] Whether or not to visualize the path\r\n   * through the polygons - e.g. the path that astar found.\r\n   * @param {boolean} [drawOptions.drawFinalPath=false] Whether or not to visualize the path\r\n   * through the path that was returned.\r\n   * @returns {Phaser.Point[]|null} An array of points if a path is found, or null if no path\r\n   *\r\n   * @memberof NavMesh\r\n   */\r\n  findPath(startPoint, endPoint, { drawPolyPath = false, drawFinalPath = false } = {}) {\r\n    let startPoly = null;\r\n    let endPoly = null;\r\n    let startDistance = Number.MAX_VALUE;\r\n    let endDistance = Number.MAX_VALUE;\r\n    let d, r;\r\n\r\n    // Find the closest poly for the starting and ending point\r\n    for (const navPoly of this._navPolygons) {\r\n      r = navPoly.boundingRadius;\r\n      // Start\r\n      d = navPoly.centroid.distance(startPoint);\r\n      if (d <= startDistance && d <= r && navPoly.contains(startPoint)) {\r\n        startPoly = navPoly;\r\n        startDistance = d;\r\n      }\r\n      // End\r\n      d = navPoly.centroid.distance(endPoint);\r\n      if (d <= endDistance && d <= r && navPoly.contains(endPoint)) {\r\n        endPoly = navPoly;\r\n        endDistance = d;\r\n      }\r\n    }\r\n\r\n    // If the start point wasn't inside a polygon, run a more liberal check that allows a point\r\n    // to be within meshShrinkAmount radius of a polygon\r\n    if (!startPoly && this._meshShrinkAmount > 0) {\r\n      for (const navPoly of this._navPolygons) {\r\n        // Check if point is within bounding circle to avoid extra projection calculations\r\n        r = navPoly.boundingRadius + this._meshShrinkAmount;\r\n        d = navPoly.centroid.distance(startPoint);\r\n        if (d <= r) {\r\n          // Check if projected point is within range of a polgyon and is closer than the\r\n          // previous point\r\n          const { distance } = this._projectPointToPolygon(startPoint, navPoly);\r\n          if (distance <= this._meshShrinkAmount && distance < startDistance) {\r\n            startPoly = navPoly;\r\n            startDistance = distance;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Same check as above, but for the end point\r\n    if (!endPoly && this._meshShrinkAmount > 0) {\r\n      for (const navPoly of this._navPolygons) {\r\n        r = navPoly.boundingRadius + this._meshShrinkAmount;\r\n        d = navPoly.centroid.distance(endPoint);\r\n        if (d <= r) {\r\n          const { distance } = this._projectPointToPolygon(endPoint, navPoly);\r\n          if (distance <= this._meshShrinkAmount && distance < endDistance) {\r\n            endPoly = navPoly;\r\n            endDistance = distance;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // No matching polygons locations for the start or end, so no path found\r\n    if (!startPoly || !endPoly) return null;\r\n\r\n    // If the start and end polygons are the same, return a direct path\r\n    if (startPoly === endPoly) {\r\n      const phaserPath = [startPoint.clone(), endPoint.clone()];\r\n      if (drawFinalPath) this.debugDrawPath(phaserPath, 0xffd900, 10);\r\n      return phaserPath;\r\n    }\r\n\r\n    // Search!\r\n    const astarPath = jsastar.astar.search(this._graph, startPoly, endPoly, {\r\n      heuristic: this._graph.navHeuristic\r\n    });\r\n\r\n    // While the start and end polygons may be valid, no path between them\r\n    if (astarPath.length === 0) return null;\r\n\r\n    // jsastar drops the first point from the path, but the funnel algorithm needs it\r\n    astarPath.unshift(startPoly);\r\n\r\n    // We have a path, so now time for the funnel algorithm\r\n    const channel = new Channel();\r\n    channel.push(startPoint);\r\n    for (let i = 0; i < astarPath.length - 1; i++) {\r\n      const navPolygon = astarPath[i];\r\n      const nextNavPolygon = astarPath[i + 1];\r\n\r\n      // Find the portal\r\n      let portal = null;\r\n      for (let i = 0; i < navPolygon.neighbors.length; i++) {\r\n        if (navPolygon.neighbors[i].id === nextNavPolygon.id) {\r\n          portal = navPolygon.portals[i];\r\n        }\r\n      }\r\n\r\n      // Push the portal vertices into the channel\r\n      channel.push(portal.start, portal.end);\r\n    }\r\n    channel.push(endPoint);\r\n\r\n    // Pull a string along the channel to run the funnel\r\n    channel.stringPull();\r\n\r\n    // Clone path, excluding duplicates\r\n    let lastPoint = null;\r\n    const phaserPath = [];\r\n    for (const p of channel.path) {\r\n      const newPoint = p.clone();\r\n      if (!lastPoint || !newPoint.equals(lastPoint)) phaserPath.push(newPoint);\r\n      lastPoint = newPoint;\r\n    }\r\n\r\n    // Call debug drawing\r\n    if (drawPolyPath) {\r\n      const polyPath = astarPath.map(elem => elem.centroid);\r\n      this.debugDrawPath(polyPath, 0x00ff00, 5);\r\n    }\r\n    if (drawFinalPath) this.debugDrawPath(phaserPath, 0xffd900, 10);\r\n\r\n    return phaserPath;\r\n  }\r\n\r\n  _calculateNeighbors() {\r\n    // Fill out the neighbor information for each navpoly\r\n    for (let i = 0; i < this._navPolygons.length; i++) {\r\n      const navPoly = this._navPolygons[i];\r\n\r\n      for (let j = i + 1; j < this._navPolygons.length; j++) {\r\n        const otherNavPoly = this._navPolygons[j];\r\n\r\n        // Check if the other navpoly is within range to touch\r\n        const d = navPoly.centroid.distance(otherNavPoly.centroid);\r\n        if (d > navPoly.boundingRadius + otherNavPoly.boundingRadius) continue;\r\n\r\n        // The are in range, so check each edge pairing\r\n        for (const edge of navPoly.edges) {\r\n          for (const otherEdge of otherNavPoly.edges) {\r\n            // If edges aren't collinear, not an option for connecting navpolys\r\n            if (!areCollinear(edge, otherEdge)) continue;\r\n\r\n            // If they are collinear, check if they overlap\r\n            const overlap = this._getSegmentOverlap(edge, otherEdge);\r\n            if (!overlap) continue;\r\n\r\n            // Connections are symmetric!\r\n            navPoly.neighbors.push(otherNavPoly);\r\n            otherNavPoly.neighbors.push(navPoly);\r\n\r\n            // Calculate the portal between the two polygons - this needs to be in\r\n            // counter-clockwise order, relative to each polygon\r\n            const [p1, p2] = overlap;\r\n            let edgeStartAngle = navPoly.centroid.angle(edge.start);\r\n            let a1 = navPoly.centroid.angle(overlap[0]);\r\n            let a2 = navPoly.centroid.angle(overlap[1]);\r\n            let d1 = angleDifference(edgeStartAngle, a1);\r\n            let d2 = angleDifference(edgeStartAngle, a2);\r\n            if (d1 < d2) {\r\n              navPoly.portals.push(new Phaser.Line(p1.x, p1.y, p2.x, p2.y));\r\n            } else {\r\n              navPoly.portals.push(new Phaser.Line(p2.x, p2.y, p1.x, p1.y));\r\n            }\r\n\r\n            edgeStartAngle = otherNavPoly.centroid.angle(otherEdge.start);\r\n            a1 = otherNavPoly.centroid.angle(overlap[0]);\r\n            a2 = otherNavPoly.centroid.angle(overlap[1]);\r\n            d1 = angleDifference(edgeStartAngle, a1);\r\n            d2 = angleDifference(edgeStartAngle, a2);\r\n            if (d1 < d2) {\r\n              otherNavPoly.portals.push(new Phaser.Line(p1.x, p1.y, p2.x, p2.y));\r\n            } else {\r\n              otherNavPoly.portals.push(new Phaser.Line(p2.x, p2.y, p1.x, p1.y));\r\n            }\r\n\r\n            // Two convex polygons shouldn't be connected more than once! (Unless\r\n            // there are unnecessary vertices...)\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Check two collinear line segments to see if they overlap by sorting the points.\r\n  // Algorithm source: http://stackoverflow.com/a/17152247\r\n  _getSegmentOverlap(line1, line2) {\r\n    const points = [\r\n      { line: line1, point: line1.start },\r\n      { line: line1, point: line1.end },\r\n      { line: line2, point: line2.start },\r\n      { line: line2, point: line2.end }\r\n    ];\r\n    points.sort(function(a, b) {\r\n      if (a.point.x < b.point.x) return -1;\r\n      else if (a.point.x > b.point.x) return 1;\r\n      else {\r\n        if (a.point.y < b.point.y) return -1;\r\n        else if (a.point.y > b.point.y) return 1;\r\n        else return 0;\r\n      }\r\n    });\r\n    // If the first two points in the array come from the same line, no overlap\r\n    const noOverlap = points[0].line === points[1].line;\r\n    // If the two middle points in the array are the same coordinates, then there is a\r\n    // single point of overlap.\r\n    const singlePointOverlap = points[1].point.equals(points[2].point);\r\n    if (noOverlap || singlePointOverlap) return null;\r\n    else return [points[1].point, points[2].point];\r\n  }\r\n\r\n  /**\r\n   * Project a point onto a polygon in the shortest distance possible.\r\n   * \r\n   * @param {Phaser.Point} point The point to project\r\n   * @param {NavPoly} navPoly The navigation polygon to test against\r\n   * @returns {{point: Phaser.Point, distance: number}}\r\n   * \r\n   * @private\r\n   * @memberof NavMesh\r\n   */\r\n  _projectPointToPolygon(point, navPoly) {\r\n    let closestProjection = null;\r\n    let closestDistance = Number.MAX_VALUE;\r\n    for (const edge of navPoly.edges) {\r\n      const projectedPoint = this._projectPointToEdge(point, edge);\r\n      const d = point.distance(projectedPoint);\r\n      if (closestProjection === null || d < closestDistance) {\r\n        closestDistance = d;\r\n        closestProjection = projectedPoint;\r\n      }\r\n    }\r\n    return { point: closestProjection, distance: closestDistance };\r\n  }\r\n\r\n  _distanceSquared(a, b) {\r\n    const dx = b.x - a.x;\r\n    const dy = b.y - a.y;\r\n    return dx * dx + dy * dy;\r\n  }\r\n\r\n  // Project a point onto a line segment\r\n  // JS Source: http://stackoverflow.com/questions/849211/shortest-distance-between-a-point-and-a-line-segment\r\n  _projectPointToEdge(point, line) {\r\n    const a = line.start;\r\n    const b = line.end;\r\n    // Consider the parametric equation for the edge's line, p = a + t (b - a). We want to find\r\n    // where our point lies on the line by solving for t:\r\n    //  t = [(p-a) . (b-a)] / |b-a|^2\r\n    const l2 = this._distanceSquared(a, b);\r\n    let t = ((point.x - a.x) * (b.x - a.x) + (point.y - a.y) * (b.y - a.y)) / l2;\r\n    // We clamp t from [0,1] to handle points outside the segment vw.\r\n    t = Phaser.Math.clamp(t, 0, 1);\r\n    // Project onto the segment\r\n    const p = new Phaser.Point(a.x + t * (b.x - a.x), a.y + t * (b.y - a.y));\r\n    return p;\r\n  }\r\n\r\n  /**\r\n   * Enable debug and create graphics overlay (if it hasn't already been created) \r\n   */\r\n  enableDebug() {\r\n    if (!this._debugGraphics) {\r\n      this._debugGraphics = this.game.add.graphics(0, 0);\r\n      this._debugGraphics.alpha = 0.5;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Disable debug and destroy associated graphics\r\n   */\r\n  disableDebug() {\r\n    if (this._debugGraphics) {\r\n      this._debugGraphics.destroy();\r\n      this._debugGraphics = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check whether debug is enabled\r\n   * \r\n   * @returns {boolean}\r\n   */\r\n  isDebugEnabled() {\r\n    return this._debugGraphics !== null;\r\n  }\r\n\r\n  /**\r\n   * Clear the debug overlay\r\n   */\r\n  debugClear() {\r\n    if (this._debugGraphics) this._debugGraphics.clear();\r\n  }\r\n\r\n  /**\r\n   * Visualize the polygons in the nav mesh as an overlay on top of the game\r\n   *\r\n   * @param {object} options\r\n   * @param {boolean} [options.drawCentroid=true] For each polygon, show the approx centroid\r\n   * @param {boolean} [options.drawBounds=false] For each polygon, show the bounding radius\r\n   * @param {boolean} [options.drawNeighbors=true] For each polygon, show the connections to\r\n   * neighbors\r\n   * @param {boolean} [options.drawPortals=true] For each polygon, show the portal edges\r\n   */\r\n  debugDrawMesh(\r\n    { drawCentroid = true, drawBounds = false, drawNeighbors = true, drawPortals = true } = {}\r\n  ) {\r\n    if (!this._debugGraphics) this.enableDebug();\r\n    // Visualize the navigation mesh\r\n    for (const navPoly of this._navPolygons) {\r\n      navPoly.draw(this._debugGraphics, drawCentroid, drawBounds, drawNeighbors, drawPortals);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Visualize a path (array of points) on the debug graphics overlay\r\n   * \r\n   * @param {Phaser.Point[]} path \r\n   * @param {number} [color=0x00FF00] \r\n   * @param {number} [thickness=10] \r\n   */\r\n  debugDrawPath(path, color = 0x00ff00, thickness = 10) {\r\n    if (!this._debugGraphics) this.enableDebug();\r\n    if (path.length) {\r\n      // Draw line for path\r\n      this._debugGraphics.lineStyle(thickness, color);\r\n      this._debugGraphics.drawShape(new Phaser.Polygon(...path));\r\n      this._debugGraphics.beginFill(color);\r\n      // Draw circle at start and end of path\r\n      const d = 0.5 * thickness;\r\n      this._debugGraphics.drawEllipse(path[0].x, path[0].y, d, d);\r\n      const lastPoint = path[path.length - 1];\r\n      this._debugGraphics.drawEllipse(lastPoint.x, lastPoint.y, d, d);\r\n      this._debugGraphics.endFill();\r\n    }\r\n  }\r\n}\r\n\r\nexport default NavMesh;\r\n\n\n\n// WEBPACK FOOTER //\n// ./nav-mesh.js","// Debug color palette\r\nconst palette = [0x00a0b0, 0x6a4a3c, 0xcc333f, 0xeb6841, 0xedc951];\r\n\r\n/**\r\n * A class that represents a navigable polygon in a navmesh. It is build from a Phaser.Polygon. It\r\n * has a drawing function to help visualize it's features:\r\n *  - polygon\r\n *  - neighbors - any navpolys that can be reached from this navpoly\r\n *  - portals - overlapping edges between neighbors\r\n *  - centroid - not a true centroid, just an approximation.\r\n *  - boundingRadius - the radius of a circle at the centroid that fits all the points of the poly \r\n * \r\n * It implements the properties and fields that javascript-astar needs - weight, toString, isWall\r\n * and getCost. See GPS test from astar repo for structure: \r\n * https://github.com/bgrins/javascript-astar/blob/master/test/tests.js\r\n *\r\n * @class NavPoly\r\n * @private\r\n */\r\nclass NavPoly {\r\n  /**\r\n   * Creates an instance of NavPoly.\r\n   * @param {Phaser.Game} game \r\n   * @param {number} id \r\n   * @param {Phaser.Polygon} polygon \r\n   * \r\n   * @memberof NavPoly\r\n   */\r\n  constructor(game, id, polygon) {\r\n    this.game = game;\r\n    this.id = id;\r\n    this.polygon = polygon;\r\n    this.edges = this._calculateEdges();\r\n    this.neighbors = [];\r\n    this.portals = [];\r\n    this.centroid = this._calculateCentroid();\r\n    this.boundingRadius = this._calculateRadius();\r\n\r\n    this.weight = 1; // jsastar property\r\n\r\n    const i = this.id % palette.length;\r\n    this._color = palette[i];\r\n  }\r\n\r\n  contains(point) {\r\n    // Phaser's polygon check doesn't handle when a point is on one of the edges of the line. Note:\r\n    // check numerical stability here. It would also be good to optimize this for different shapes.\r\n    return this.polygon.contains(point.x, point.y) || this._isPointOnEdge(point);\r\n  }\r\n\r\n  destroy() {\r\n    this.game = null;\r\n    this.neighbors = [];\r\n    this.portals = [];\r\n  }\r\n\r\n  // jsastar methods\r\n  toString() {\r\n    return `NavPoly(id: ${this.id} at: ${this.centroid})`;\r\n  }\r\n  isWall() {\r\n    return this.weight === 0;\r\n  }\r\n  centroidDistance(navPolygon) {\r\n    return this.centroid.distance(navPolygon.centroid);\r\n  }\r\n  getCost(navPolygon) {\r\n    return this.centroidDistance(navPolygon);\r\n  }\r\n\r\n  _calculateEdges() {\r\n    const points = this.polygon.points;\r\n    const edges = [];\r\n    for (let i = 1; i < points.length; i++) {\r\n      const p1 = points[i - 1];\r\n      const p2 = points[i];\r\n      edges.push(new Phaser.Line(p1.x, p1.y, p2.x, p2.y));\r\n    }\r\n    const first = points[0];\r\n    const last = points[points.length - 1];\r\n    edges.push(new Phaser.Line(first.x, first.y, last.x, last.y));\r\n    return edges;\r\n  }\r\n\r\n  _calculateCentroid() {\r\n    // NOTE: this is not actually the centroid, it's the average of the vertices - not the same\r\n    // thing!\r\n    const centroid = new Phaser.Point(0, 0);\r\n    const length = this.polygon.points.length;\r\n    for (const point of this.polygon.points) {\r\n      centroid.add(point.x, point.y);\r\n    }\r\n    centroid.divide(length, length);\r\n    return centroid;\r\n  }\r\n\r\n  _calculateRadius() {\r\n    let boundingRadius = 0;\r\n    for (const point of this.polygon.points) {\r\n      const d = this.centroid.distance(point);\r\n      if (d > boundingRadius) boundingRadius = d;\r\n    }\r\n    return boundingRadius;\r\n  }\r\n\r\n  _isPointOnEdge(point) {\r\n    for (const edge of this.edges) {\r\n      if (edge.pointOnSegment(point.x, point.y)) return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Draw the polygon to given graphics object\r\n   * \r\n   * @param {Phaser.Graphics} graphics \r\n   * @param {boolean} [drawCentroid=true] Show the approx centroid\r\n   * @param {boolean} [drawBounds=false] Show the bounding radius\r\n   * @param {boolean} [drawNeighbors=true] Show the connections to neighbors\r\n   * @param {boolean} [drawPortals=true] Show the portal edges\r\n   * \r\n   * @memberof NavPoly\r\n   */\r\n  draw(\r\n    graphics,\r\n    drawCentroid = true,\r\n    drawBounds = false,\r\n    drawNeighbors = true,\r\n    drawPortals = true\r\n  ) {\r\n    graphics.lineWidth = 0;\r\n    graphics.beginFill(this._color);\r\n    graphics.drawPolygon(this.polygon);\r\n    graphics.endFill();\r\n\r\n    if (drawCentroid) {\r\n      graphics.beginFill(0x000000);\r\n      graphics.drawEllipse(this.centroid.x, this.centroid.y, 4, 4);\r\n      graphics.endFill();\r\n    }\r\n\r\n    if (drawBounds) {\r\n      graphics.lineStyle(1, 0xffffff);\r\n      const r = this.boundingRadius;\r\n      graphics.drawEllipse(this.centroid.x, this.centroid.y, r, r);\r\n    }\r\n\r\n    if (drawNeighbors) {\r\n      graphics.lineStyle(2, 0x000000);\r\n      for (const n of this.neighbors) {\r\n        graphics.moveTo(this.centroid.x, this.centroid.y);\r\n        graphics.lineTo(n.centroid.x, n.centroid.y);\r\n      }\r\n    }\r\n\r\n    if (drawPortals) {\r\n      graphics.lineStyle(10, 0x000000);\r\n      for (const p of this.portals) {\r\n        graphics.moveTo(p.start.x, p.start.y);\r\n        graphics.lineTo(p.end.x, p.end.y);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport default NavPoly;\r\n\n\n\n// WEBPACK FOOTER //\n// ./nav-poly.js"],"sourceRoot":""}