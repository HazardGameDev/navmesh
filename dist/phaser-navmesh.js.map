{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 1e1f6e5e13802be39203","webpack:///./utils.js","webpack:///E:/Github/navmesh-phaser-plugin/~/javascript-astar/astar.js","webpack:///./nav-mesh-plugin.js","webpack:///./channel.js","webpack:///./index.js","webpack:///./nav-graph.js","webpack:///./nav-mesh.js","webpack:///./nav-poly.js"],"names":["triarea2","a","b","c","ax","x","ay","y","bx","by","almostEqual","value1","value2","errorMargin","Math","abs","angleDifference","i","PI","j","floor","areCollinear","line1","line2","area1","start","end","area2","NavMeshPlugin","game","manager","_navMeshes","tilemap","objectKey","meshShrinkAmount","objects","console","warn","length","rects","polygons","r","top","bottom","height","left","right","width","poly","Phaser","Polygon","push","mesh","destroy","Plugin","Channel","portals","p1","p2","pts","portalApex","portalLeft","portalRight","apexIndex","leftIndex","rightIndex","equals","path","module","exports","require","default","NavGraph","navPolygons","nodes","init","navPolygon","neighbors","navPolygon1","navPolygon2","centroidDistance","cleanDirty","prototype","jsastar","Graph","markDirty","NavMesh","_debugGraphics","_meshShrinkAmount","_navPolygons","entries","polygon","_calculateNeighbors","_graph","disableDebug","startPoint","endPoint","drawPolyPath","drawFinalPath","startPoly","endPoly","startDistance","Number","MAX_VALUE","endDistance","d","navPoly","boundingRadius","centroid","distance","contains","_projectPointToPolygon","phaserPath","clone","debugDrawPath","astarPath","astar","search","heuristic","navHeuristic","unshift","channel","nextNavPolygon","portal","id","stringPull","lastPoint","p","newPoint","polyPath","map","elem","otherNavPoly","edges","edge","otherEdge","overlap","_getSegmentOverlap","edgeStartAngle","angle","a1","a2","d1","d2","Line","points","line","point","sort","noOverlap","singlePointOverlap","closestProjection","closestDistance","projectedPoint","_projectPointToEdge","dx","dy","l2","_distanceSquared","t","clamp","Point","add","graphics","alpha","clear","drawCentroid","drawBounds","drawNeighbors","drawPortals","enableDebug","draw","color","thickness","lineStyle","drawShape","beginFill","drawEllipse","endFill","palette","NavPoly","_calculateEdges","_calculateCentroid","_calculateRadius","weight","_color","_isPointOnEdge","first","last","divide","pointOnSegment","lineWidth","drawPolygon","n","moveTo","lineTo"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,mDAA2C,cAAc;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;;;;AChEA;AAAA;;;;AAIO,SAASA,QAAT,CAAkBC,CAAlB,EAAqBC,CAArB,EAAwBC,CAAxB,EAA2B;AAChC,MAAMC,KAAKF,EAAEG,CAAF,GAAMJ,EAAEI,CAAnB;AACA,MAAMC,KAAKJ,EAAEK,CAAF,GAAMN,EAAEM,CAAnB;AACA,MAAMC,KAAKL,EAAEE,CAAF,GAAMJ,EAAEI,CAAnB;AACA,MAAMI,KAAKN,EAAEI,CAAF,GAAMN,EAAEM,CAAnB;AACA,SAAOC,KAAKF,EAAL,GAAUF,KAAKK,EAAtB;AACD;;AAED;;;AAGO,SAASC,WAAT,CAAqBC,MAArB,EAA6BC,MAA7B,EAA2D;AAAA,MAAtBC,WAAsB,uEAAR,MAAQ;;AAChE,MAAIC,KAAKC,GAAL,CAASJ,SAASC,MAAlB,KAA6BC,WAAjC,EAA8C,OAAO,IAAP,CAA9C,KACK,OAAO,KAAP;AACN;;AAED;;;;AAIO,SAASG,eAAT,CAAyBX,CAAzB,EAA4BE,CAA5B,EAA+B;AACpC,MAAIN,IAAII,IAAIE,CAAZ;AACA,MAAMU,IAAIhB,IAAIa,KAAKI,EAAnB;AACA,MAAMC,IAAIL,KAAKI,EAAL,GAAU,CAApB;AACAjB,MAAIgB,IAAIH,KAAKM,KAAL,CAAWH,IAAIE,CAAf,IAAoBA,CAA5B,CAJoC,CAIL;AAC/BlB,OAAKa,KAAKI,EAAV;AACA,SAAOjB,CAAP;AACD;;AAED;;;AAGO,SAASoB,YAAT,CAAsBC,KAAtB,EAA6BC,KAA7B,EAA0D;AAAA,MAAtBV,WAAsB,uEAAR,MAAQ;;AAC/D;AACA;AACA,MAAMW,QAAQxB,SAASsB,MAAMG,KAAf,EAAsBH,MAAMI,GAA5B,EAAiCH,MAAME,KAAvC,CAAd;AACA,MAAME,QAAQ3B,SAASsB,MAAMG,KAAf,EAAsBH,MAAMI,GAA5B,EAAiCH,MAAMG,GAAvC,CAAd;AACA,MAAIhB,YAAYc,KAAZ,EAAmB,CAAnB,EAAsBX,WAAtB,KAAsCH,YAAYiB,KAAZ,EAAmB,CAAnB,EAAsBd,WAAtB,CAA1C,EAA8E;AAC5E,WAAO,IAAP;AACD,GAFD,MAEO,OAAO,KAAP;AACR,C;;;;;;AC5CD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AAAA;AAAA;AAAA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,SAAS;AACrB,YAAY,SAAS;AACrB,YAAY,OAAO;AACnB,YAAY,KAAK;AACjB;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B;;AAE5B;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,4CAA4C,QAAQ;AACpD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,WAAW,KAAK;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,mBAAmB;AACpC;;AAEA,oCAAoC,gBAAgB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,uBAAuB;AACxC;AACA;AACA;;AAEA;AACA,iBAAiB,4BAA4B;AAC7C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AA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","file":"phaser-navmesh.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"PhaserNavmesh\"] = factory();\n\telse\n\t\troot[\"PhaserNavmesh\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 1e1f6e5e13802be39203","/**\r\n * Twice the area of the triangle formed by a, b and c\r\n * @private\r\n */\r\nexport function triarea2(a, b, c) {\r\n  const ax = b.x - a.x;\r\n  const ay = b.y - a.y;\r\n  const bx = c.x - a.x;\r\n  const by = c.y - a.y;\r\n  return bx * ay - ax * by;\r\n}\r\n\r\n/**\r\n * @private\r\n */\r\nexport function almostEqual(value1, value2, errorMargin = 0.0001) {\r\n  if (Math.abs(value1 - value2) <= errorMargin) return true;\r\n  else return false;\r\n}\r\n\r\n/**\r\n * https://gist.github.com/Aaronduino/4068b058f8dbc34b4d3a9eedc8b2cbe0\r\n * @private\r\n */\r\nexport function angleDifference(x, y) {\r\n  let a = x - y;\r\n  const i = a + Math.PI;\r\n  const j = Math.PI * 2;\r\n  a = i - Math.floor(i / j) * j; // (a+180) % 360; this ensures the correct sign\r\n  a -= Math.PI;\r\n  return a;\r\n}\r\n\r\n/**\r\n * @private\r\n */\r\nexport function areCollinear(line1, line2, errorMargin = 0.0001) {\r\n  // Figure out if the two lines are equal by looking at the area of the triangle formed\r\n  // by their points\r\n  const area1 = triarea2(line1.start, line1.end, line2.start);\r\n  const area2 = triarea2(line1.start, line1.end, line2.end);\r\n  if (almostEqual(area1, 0, errorMargin) && almostEqual(area2, 0, errorMargin)) {\r\n    return true;\r\n  } else return false;\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./utils.js","// javascript-astar 0.4.2\r\n// http://github.com/bgrins/javascript-astar\r\n// Freely distributable under the MIT License.\r\n// Implements the astar search algorithm in javascript using a Binary Heap.\r\n// Includes Binary Heap (with modifications) from Marijn Haverbeke.\r\n// http://eloquentjavascript.net/appendix2.html\r\n(function(definition) {\r\n  /* global module, define */\r\n  if (typeof module === 'object' && typeof module.exports === 'object') {\r\n    module.exports = definition();\r\n  } else if (typeof define === 'function' && define.amd) {\r\n    define([], definition);\r\n  } else {\r\n    var exports = definition();\r\n    window.astar = exports.astar;\r\n    window.Graph = exports.Graph;\r\n  }\r\n})(function() {\r\n\r\nfunction pathTo(node) {\r\n  var curr = node;\r\n  var path = [];\r\n  while (curr.parent) {\r\n    path.unshift(curr);\r\n    curr = curr.parent;\r\n  }\r\n  return path;\r\n}\r\n\r\nfunction getHeap() {\r\n  return new BinaryHeap(function(node) {\r\n    return node.f;\r\n  });\r\n}\r\n\r\nvar astar = {\r\n  /**\r\n  * Perform an A* Search on a graph given a start and end node.\r\n  * @param {Graph} graph\r\n  * @param {GridNode} start\r\n  * @param {GridNode} end\r\n  * @param {Object} [options]\r\n  * @param {bool} [options.closest] Specifies whether to return the\r\n             path to the closest node if the target is unreachable.\r\n  * @param {Function} [options.heuristic] Heuristic function (see\r\n  *          astar.heuristics).\r\n  */\r\n  search: function(graph, start, end, options) {\r\n    graph.cleanDirty();\r\n    options = options || {};\r\n    var heuristic = options.heuristic || astar.heuristics.manhattan;\r\n    var closest = options.closest || false;\r\n\r\n    var openHeap = getHeap();\r\n    var closestNode = start; // set the start node to be the closest if required\r\n\r\n    start.h = heuristic(start, end);\r\n    graph.markDirty(start);\r\n\r\n    openHeap.push(start);\r\n\r\n    while (openHeap.size() > 0) {\r\n\r\n      // Grab the lowest f(x) to process next.  Heap keeps this sorted for us.\r\n      var currentNode = openHeap.pop();\r\n\r\n      // End case -- result has been found, return the traced path.\r\n      if (currentNode === end) {\r\n        return pathTo(currentNode);\r\n      }\r\n\r\n      // Normal case -- move currentNode from open to closed, process each of its neighbors.\r\n      currentNode.closed = true;\r\n\r\n      // Find all neighbors for the current node.\r\n      var neighbors = graph.neighbors(currentNode);\r\n\r\n      for (var i = 0, il = neighbors.length; i < il; ++i) {\r\n        var neighbor = neighbors[i];\r\n\r\n        if (neighbor.closed || neighbor.isWall()) {\r\n          // Not a valid node to process, skip to next neighbor.\r\n          continue;\r\n        }\r\n\r\n        // The g score is the shortest distance from start to current node.\r\n        // We need to check if the path we have arrived at this neighbor is the shortest one we have seen yet.\r\n        var gScore = currentNode.g + neighbor.getCost(currentNode);\r\n        var beenVisited = neighbor.visited;\r\n\r\n        if (!beenVisited || gScore < neighbor.g) {\r\n\r\n          // Found an optimal (so far) path to this node.  Take score for node to see how good it is.\r\n          neighbor.visited = true;\r\n          neighbor.parent = currentNode;\r\n          neighbor.h = neighbor.h || heuristic(neighbor, end);\r\n          neighbor.g = gScore;\r\n          neighbor.f = neighbor.g + neighbor.h;\r\n          graph.markDirty(neighbor);\r\n          if (closest) {\r\n            // If the neighbour is closer than the current closestNode or if it's equally close but has\r\n            // a cheaper path than the current closest node then it becomes the closest node\r\n            if (neighbor.h < closestNode.h || (neighbor.h === closestNode.h && neighbor.g < closestNode.g)) {\r\n              closestNode = neighbor;\r\n            }\r\n          }\r\n\r\n          if (!beenVisited) {\r\n            // Pushing to heap will put it in proper place based on the 'f' value.\r\n            openHeap.push(neighbor);\r\n          } else {\r\n            // Already seen the node, but since it has been rescored we need to reorder it in the heap\r\n            openHeap.rescoreElement(neighbor);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (closest) {\r\n      return pathTo(closestNode);\r\n    }\r\n\r\n    // No result was found - empty array signifies failure to find path.\r\n    return [];\r\n  },\r\n  // See list of heuristics: http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html\r\n  heuristics: {\r\n    manhattan: function(pos0, pos1) {\r\n      var d1 = Math.abs(pos1.x - pos0.x);\r\n      var d2 = Math.abs(pos1.y - pos0.y);\r\n      return d1 + d2;\r\n    },\r\n    diagonal: function(pos0, pos1) {\r\n      var D = 1;\r\n      var D2 = Math.sqrt(2);\r\n      var d1 = Math.abs(pos1.x - pos0.x);\r\n      var d2 = Math.abs(pos1.y - pos0.y);\r\n      return (D * (d1 + d2)) + ((D2 - (2 * D)) * Math.min(d1, d2));\r\n    }\r\n  },\r\n  cleanNode: function(node) {\r\n    node.f = 0;\r\n    node.g = 0;\r\n    node.h = 0;\r\n    node.visited = false;\r\n    node.closed = false;\r\n    node.parent = null;\r\n  }\r\n};\r\n\r\n/**\r\n * A graph memory structure\r\n * @param {Array} gridIn 2D array of input weights\r\n * @param {Object} [options]\r\n * @param {bool} [options.diagonal] Specifies whether diagonal moves are allowed\r\n */\r\nfunction Graph(gridIn, options) {\r\n  options = options || {};\r\n  this.nodes = [];\r\n  this.diagonal = !!options.diagonal;\r\n  this.grid = [];\r\n  for (var x = 0; x < gridIn.length; x++) {\r\n    this.grid[x] = [];\r\n\r\n    for (var y = 0, row = gridIn[x]; y < row.length; y++) {\r\n      var node = new GridNode(x, y, row[y]);\r\n      this.grid[x][y] = node;\r\n      this.nodes.push(node);\r\n    }\r\n  }\r\n  this.init();\r\n}\r\n\r\nGraph.prototype.init = function() {\r\n  this.dirtyNodes = [];\r\n  for (var i = 0; i < this.nodes.length; i++) {\r\n    astar.cleanNode(this.nodes[i]);\r\n  }\r\n};\r\n\r\nGraph.prototype.cleanDirty = function() {\r\n  for (var i = 0; i < this.dirtyNodes.length; i++) {\r\n    astar.cleanNode(this.dirtyNodes[i]);\r\n  }\r\n  this.dirtyNodes = [];\r\n};\r\n\r\nGraph.prototype.markDirty = function(node) {\r\n  this.dirtyNodes.push(node);\r\n};\r\n\r\nGraph.prototype.neighbors = function(node) {\r\n  var ret = [];\r\n  var x = node.x;\r\n  var y = node.y;\r\n  var grid = this.grid;\r\n\r\n  // West\r\n  if (grid[x - 1] && grid[x - 1][y]) {\r\n    ret.push(grid[x - 1][y]);\r\n  }\r\n\r\n  // East\r\n  if (grid[x + 1] && grid[x + 1][y]) {\r\n    ret.push(grid[x + 1][y]);\r\n  }\r\n\r\n  // South\r\n  if (grid[x] && grid[x][y - 1]) {\r\n    ret.push(grid[x][y - 1]);\r\n  }\r\n\r\n  // North\r\n  if (grid[x] && grid[x][y + 1]) {\r\n    ret.push(grid[x][y + 1]);\r\n  }\r\n\r\n  if (this.diagonal) {\r\n    // Southwest\r\n    if (grid[x - 1] && grid[x - 1][y - 1]) {\r\n      ret.push(grid[x - 1][y - 1]);\r\n    }\r\n\r\n    // Southeast\r\n    if (grid[x + 1] && grid[x + 1][y - 1]) {\r\n      ret.push(grid[x + 1][y - 1]);\r\n    }\r\n\r\n    // Northwest\r\n    if (grid[x - 1] && grid[x - 1][y + 1]) {\r\n      ret.push(grid[x - 1][y + 1]);\r\n    }\r\n\r\n    // Northeast\r\n    if (grid[x + 1] && grid[x + 1][y + 1]) {\r\n      ret.push(grid[x + 1][y + 1]);\r\n    }\r\n  }\r\n\r\n  return ret;\r\n};\r\n\r\nGraph.prototype.toString = function() {\r\n  var graphString = [];\r\n  var nodes = this.grid;\r\n  for (var x = 0; x < nodes.length; x++) {\r\n    var rowDebug = [];\r\n    var row = nodes[x];\r\n    for (var y = 0; y < row.length; y++) {\r\n      rowDebug.push(row[y].weight);\r\n    }\r\n    graphString.push(rowDebug.join(\" \"));\r\n  }\r\n  return graphString.join(\"\\n\");\r\n};\r\n\r\nfunction GridNode(x, y, weight) {\r\n  this.x = x;\r\n  this.y = y;\r\n  this.weight = weight;\r\n}\r\n\r\nGridNode.prototype.toString = function() {\r\n  return \"[\" + this.x + \" \" + this.y + \"]\";\r\n};\r\n\r\nGridNode.prototype.getCost = function(fromNeighbor) {\r\n  // Take diagonal weight into consideration.\r\n  if (fromNeighbor && fromNeighbor.x != this.x && fromNeighbor.y != this.y) {\r\n    return this.weight * 1.41421;\r\n  }\r\n  return this.weight;\r\n};\r\n\r\nGridNode.prototype.isWall = function() {\r\n  return this.weight === 0;\r\n};\r\n\r\nfunction BinaryHeap(scoreFunction) {\r\n  this.content = [];\r\n  this.scoreFunction = scoreFunction;\r\n}\r\n\r\nBinaryHeap.prototype = {\r\n  push: function(element) {\r\n    // Add the new element to the end of the array.\r\n    this.content.push(element);\r\n\r\n    // Allow it to sink down.\r\n    this.sinkDown(this.content.length - 1);\r\n  },\r\n  pop: function() {\r\n    // Store the first element so we can return it later.\r\n    var result = this.content[0];\r\n    // Get the element at the end of the array.\r\n    var end = this.content.pop();\r\n    // If there are any elements left, put the end element at the\r\n    // start, and let it bubble up.\r\n    if (this.content.length > 0) {\r\n      this.content[0] = end;\r\n      this.bubbleUp(0);\r\n    }\r\n    return result;\r\n  },\r\n  remove: function(node) {\r\n    var i = this.content.indexOf(node);\r\n\r\n    // When it is found, the process seen in 'pop' is repeated\r\n    // to fill up the hole.\r\n    var end = this.content.pop();\r\n\r\n    if (i !== this.content.length - 1) {\r\n      this.content[i] = end;\r\n\r\n      if (this.scoreFunction(end) < this.scoreFunction(node)) {\r\n        this.sinkDown(i);\r\n      } else {\r\n        this.bubbleUp(i);\r\n      }\r\n    }\r\n  },\r\n  size: function() {\r\n    return this.content.length;\r\n  },\r\n  rescoreElement: function(node) {\r\n    this.sinkDown(this.content.indexOf(node));\r\n  },\r\n  sinkDown: function(n) {\r\n    // Fetch the element that has to be sunk.\r\n    var element = this.content[n];\r\n\r\n    // When at 0, an element can not sink any further.\r\n    while (n > 0) {\r\n\r\n      // Compute the parent element's index, and fetch it.\r\n      var parentN = ((n + 1) >> 1) - 1;\r\n      var parent = this.content[parentN];\r\n      // Swap the elements if the parent is greater.\r\n      if (this.scoreFunction(element) < this.scoreFunction(parent)) {\r\n        this.content[parentN] = element;\r\n        this.content[n] = parent;\r\n        // Update 'n' to continue at the new position.\r\n        n = parentN;\r\n      }\r\n      // Found a parent that is less, no need to sink any further.\r\n      else {\r\n        break;\r\n      }\r\n    }\r\n  },\r\n  bubbleUp: function(n) {\r\n    // Look up the target element and its score.\r\n    var length = this.content.length;\r\n    var element = this.content[n];\r\n    var elemScore = this.scoreFunction(element);\r\n\r\n    while (true) {\r\n      // Compute the indices of the child elements.\r\n      var child2N = (n + 1) << 1;\r\n      var child1N = child2N - 1;\r\n      // This is used to store the new position of the element, if any.\r\n      var swap = null;\r\n      var child1Score;\r\n      // If the first child exists (is inside the array)...\r\n      if (child1N < length) {\r\n        // Look it up and compute its score.\r\n        var child1 = this.content[child1N];\r\n        child1Score = this.scoreFunction(child1);\r\n\r\n        // If the score is less than our element's, we need to swap.\r\n        if (child1Score < elemScore) {\r\n          swap = child1N;\r\n        }\r\n      }\r\n\r\n      // Do the same checks for the other child.\r\n      if (child2N < length) {\r\n        var child2 = this.content[child2N];\r\n        var child2Score = this.scoreFunction(child2);\r\n        if (child2Score < (swap === null ? elemScore : child1Score)) {\r\n          swap = child2N;\r\n        }\r\n      }\r\n\r\n      // If the element needs to be moved, swap it, and continue.\r\n      if (swap !== null) {\r\n        this.content[n] = this.content[swap];\r\n        this.content[swap] = element;\r\n        n = swap;\r\n      }\r\n      // Otherwise, we are done.\r\n      else {\r\n        break;\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nreturn {\r\n  astar: astar,\r\n  Graph: Graph\r\n};\r\n\r\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// E:/Github/navmesh-phaser-plugin/~/javascript-astar/astar.js\n// module id = 1\n// module chunks = 0 1","// const triangulate = require(\"./triangulate\");\r\nimport NavMesh from \"./nav-mesh\";\r\n\r\n/**\r\n * This plugin can create navigation meshes for use in Phaser. The navmeshes can be constructed from\r\n * convex polygons embedded in a Tiled map. Instantiate this using game.plugins.add(NavMeshPlugin).\r\n *\r\n * @param {Phaser.Game} game\r\n * @param {Phaser.PluginManager} manager\r\n */\r\nexport default class NavMeshPlugin extends Phaser.Plugin {\r\n  constructor(game, manager) {\r\n    super(game, manager);\r\n    this._navMeshes = [];\r\n  }\r\n\r\n  /**\r\n   * Load a navmesh from Tiled and switch it to be the current navmesh. Currently assumes that the\r\n   * polygons are squares!\r\n   * \r\n   * @param {Phaser.Tilemap} tilemap The tilemap that contains polygons under an object layer\r\n   * @param {string} objectKey The name of the object layer in the tilemap\r\n   * @param {number} [meshShrinkAmount=0] The amount (in pixels) that the navmesh has been\r\n   * shrunk around obstacles (a.k.a the amount obstacles have been expanded)\r\n   * \r\n   * @memberof NavMeshPlugin\r\n   */\r\n  buildMeshFromTiled(tilemap, objectKey, meshShrinkAmount = 0) {\r\n    if (!tilemap.objects[objectKey]) {\r\n      console.warn(\r\n        `NavMeshPlugin: The given tilemap has no object layer with the name \"${objectKey}\"`\r\n      );\r\n    } else if (tilemap.objects[objectKey].length === 0) {\r\n      console.warn(\r\n        `NavMeshPlugin: The \"${objectKey}\" object layer in the Tilemap has 0 objects in it`\r\n      );\r\n    }\r\n    // Load up the object layer\r\n    const rects = tilemap.objects[objectKey] || [];\r\n    // Loop over the objects and construct a polygon\r\n    const polygons = [];\r\n    for (const r of rects) {\r\n      const top = r.y;\r\n      const bottom = r.y + r.height;\r\n      const left = r.x;\r\n      const right = r.x + r.width;\r\n      const poly = new Phaser.Polygon(left, top, left, bottom, right, bottom, right, top);\r\n      polygons.push(poly);\r\n    }\r\n    // Build the navmesh\r\n    const mesh = new NavMesh(this.game, polygons, meshShrinkAmount);\r\n    this._navMeshes.push(mesh);\r\n    return mesh;\r\n  }\r\n\r\n  destroy() {\r\n    for (const mesh of this._navMeshes) mesh.destroy();\r\n    this._navMeshes = [];\r\n    super.destroy();\r\n  }\r\n\r\n  // /**\r\n  //  * Build a navmesh from an array of convex polygons. This currently tesselates the polygons into\r\n  //  * triangles. They aren't as efficient or as well designed as ones made by hand in Tiled.\r\n  //  *\r\n  //  * @param {string} levelName The key to use to store the navmesh in the plugin\r\n  //  * @param {[]} hulls An array of convex polygons describing the obstacles in the\r\n  //  * level. See lighting-plugin/hull-from-tiles.\r\n  //  *\r\n  //  * @memberof NavMeshPlugin\r\n  //  */\r\n  // buildMesh(levelName, hulls) {\r\n  //     const contours = this._buildContours(hulls);\r\n  //     // Get an array of triangulated vertices\r\n  //     const triangles = triangulate(contours, false); // Counter-clockwise ordering!\r\n  //     const polygons = [];\r\n  //     for (let i = 0; i < triangles.length; i += 6) {\r\n  //         const poly = new Phaser.Polygon(\r\n  //             // These should be in counter-clockwise order from triangulate\r\n  //             triangles[i + 0], triangles[i + 1],\r\n  //             triangles[i + 2], triangles[i + 3],\r\n  //             triangles[i + 4], triangles[i + 5]\r\n  //         );\r\n  //         polygons.push(poly);\r\n  //     }\r\n  //     const navMesh = new NavMesh(this.game, polygons);\r\n  //     this._navMeshes[levelName] = navMesh;\r\n  //     this._currentNavMesh = navMesh;\r\n  // }\r\n\r\n  // /**\r\n  //  * @param {[]} hulls\r\n  //  * @returns\r\n  //  *\r\n  //  * @memberof NavMeshPlugin\r\n  //  */\r\n  // _buildContours(hulls) {\r\n  //     const w = this.game.width;\r\n  //     const h = this.game.height;\r\n  //     // Start the contours\r\n  //     const contours = [\r\n  //         // Full screen - counter clockwise\r\n  //         Float32Array.of(0,0, 0,h, w,h, w,0)\r\n  //     ];\r\n  //     // For each convex hull add the contour\r\n  //     for (const hull of hulls) {\r\n  //         const contour = [];\r\n  //         for (const lineInfo of hull) {\r\n  //             contour.push(lineInfo.line.start.x, lineInfo.line.start.y);\r\n  //         }\r\n  //         contours.push(Float32Array.from(contour));\r\n  //     }\r\n  //     return contours;\r\n  // }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./nav-mesh-plugin.js","// Mostly sourced from PatrolJS at the moment. TODO: come back and reimplement this as an incomplete\r\n// funnel algorithm so astar checks can be more accurate.\r\n\r\nimport { triarea2 } from \"./utils\";\r\n\r\n/**\r\n * @private\r\n */\r\nclass Channel {\r\n  constructor() {\r\n    this.portals = [];\r\n  }\r\n\r\n  /**\r\n   * @param {Phaser.Point} p1 \r\n   * @param {Phaser.Point} p2 \r\n   * \r\n   * @memberof Channel\r\n   */\r\n  push(p1, p2 = null) {\r\n    if (p2 === null) p2 = p1;\r\n    this.portals.push({\r\n      left: p1,\r\n      right: p2\r\n    });\r\n  }\r\n\r\n  stringPull() {\r\n    var portals = this.portals;\r\n    var pts = [];\r\n    // Init scan state\r\n    var portalApex, portalLeft, portalRight;\r\n    var apexIndex = 0,\r\n      leftIndex = 0,\r\n      rightIndex = 0;\r\n\r\n    portalApex = portals[0].left;\r\n    portalLeft = portals[0].left;\r\n    portalRight = portals[0].right;\r\n\r\n    // Add start point.\r\n    pts.push(portalApex);\r\n\r\n    for (var i = 1; i < portals.length; i++) {\r\n      // Find the next portal vertices\r\n      var left = portals[i].left;\r\n      var right = portals[i].right;\r\n\r\n      // Update right vertex.\r\n      if (triarea2(portalApex, portalRight, right) <= 0.0) {\r\n        if (portalApex.equals(portalRight) || triarea2(portalApex, portalLeft, right) > 0.0) {\r\n          // Tighten the funnel.\r\n          portalRight = right;\r\n          rightIndex = i;\r\n        } else {\r\n          // Right vertex just crossed over the left vertex, so the left vertex should\r\n          // now be part of the path.\r\n          pts.push(portalLeft);\r\n\r\n          // Restart scan from portal left point.\r\n\r\n          // Make current left the new apex.\r\n          portalApex = portalLeft;\r\n          apexIndex = leftIndex;\r\n          // Reset portal\r\n          portalLeft = portalApex;\r\n          portalRight = portalApex;\r\n          leftIndex = apexIndex;\r\n          rightIndex = apexIndex;\r\n          // Restart scan\r\n          i = apexIndex;\r\n          continue;\r\n        }\r\n      }\r\n\r\n      // Update left vertex.\r\n      if (triarea2(portalApex, portalLeft, left) >= 0.0) {\r\n        if (portalApex.equals(portalLeft) || triarea2(portalApex, portalRight, left) < 0.0) {\r\n          // Tighten the funnel.\r\n          portalLeft = left;\r\n          leftIndex = i;\r\n        } else {\r\n          // Left vertex just crossed over the right vertex, so the right vertex should\r\n          // now be part of the path\r\n          pts.push(portalRight);\r\n\r\n          // Restart scan from portal right point.\r\n\r\n          // Make current right the new apex.\r\n          portalApex = portalRight;\r\n          apexIndex = rightIndex;\r\n          // Reset portal\r\n          portalLeft = portalApex;\r\n          portalRight = portalApex;\r\n          leftIndex = apexIndex;\r\n          rightIndex = apexIndex;\r\n          // Restart scan\r\n          i = apexIndex;\r\n          continue;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (pts.length === 0 || !pts[pts.length - 1].equals(portals[portals.length - 1].left)) {\r\n      // Append last point to path.\r\n      pts.push(portals[portals.length - 1].left);\r\n    }\r\n\r\n    this.path = pts;\r\n    return pts;\r\n  }\r\n}\r\n\r\nexport default Channel;\r\n\n\n\n// WEBPACK FOOTER //\n// ./channel.js","// Fix for webpack not exporting ES6 module default properly when using global mode of UMD. It ends\r\n// up with someone having to do \"PhaserNavmesh.default\" instead of \"PhaserNavmesh\"\r\nmodule.exports = require(\"./nav-mesh-plugin\").default;\r\n\n\n\n// WEBPACK FOOTER //\n// ./index.js","import jsastar from \"javascript-astar\";\r\n\r\n/**\r\n * Graph for javascript-astar. It implements the functionality for astar. See GPS test from astar\r\n * repo for structure: https://github.com/bgrins/javascript-astar/blob/master/test/tests.js\r\n *\r\n * @class NavGraph \r\n * @private\r\n */\r\nclass NavGraph {\r\n  constructor(navPolygons) {\r\n    this.nodes = navPolygons;\r\n    this.init();\r\n  }\r\n\r\n  neighbors(navPolygon) {\r\n    return navPolygon.neighbors;\r\n  }\r\n\r\n  navHeuristic(navPolygon1, navPolygon2) {\r\n    return navPolygon1.centroidDistance(navPolygon2);\r\n  }\r\n\r\n  destroy() {\r\n    this.cleanDirty();\r\n    this.nodes = [];\r\n  }\r\n}\r\n\r\nNavGraph.prototype.init = jsastar.Graph.prototype.init;\r\nNavGraph.prototype.cleanDirty = jsastar.Graph.prototype.cleanDirty;\r\nNavGraph.prototype.markDirty = jsastar.Graph.prototype.markDirty;\r\n\r\nexport default NavGraph;\r\n\n\n\n// WEBPACK FOOTER //\n// ./nav-graph.js","import jsastar from \"javascript-astar\";\r\nimport NavPoly from \"./nav-poly\";\r\nimport NavGraph from \"./nav-graph\";\r\nimport Channel from \"./channel\";\r\nimport { angleDifference, areCollinear } from \"./utils\";\r\n\r\n/**\r\n * The workhorse that represents a navigation mesh built from a series of polygons. Once built, the\r\n * mesh can be asked for a path from one point to another point. It has debug methods for \r\n * visualizing paths and visualizing the individual polygons. Some internal terminology usage:\r\n * \r\n * - neighbor: a polygon that shares part of an edge with another polygon\r\n * - portal: when two neighbor's have edges that overlap, the portal is the overlapping line segment\r\n * - channel: the path of polygons from starting point to end point\r\n * - pull the string: run the funnel algorithm on the channel so that the path hugs the edges of the\r\n *   channel. Equivalent to having a string snaking through a hallway and then pulling it taut.\r\n */\r\nclass NavMesh {\r\n  /**\r\n   * Creates an instance of NavMesh.\r\n   * \r\n   * @param {Phaser.Game} game\r\n   * @param {Phaser.Polygon[]} polygons\r\n   * @param {number} [meshShrinkAmount=0] The amount (in pixels) that the navmesh has been\r\n   * shrunk around obstacles (a.k.a the amount obstacles have been expanded)\r\n   */\r\n  constructor(game, polygons, meshShrinkAmount = 0) {\r\n    this.game = game;\r\n    this._debugGraphics = null;\r\n    this._meshShrinkAmount = meshShrinkAmount;\r\n\r\n    // Construct NavPoly instances for each polygon\r\n    this._navPolygons = [];\r\n    for (const [i, polygon] of polygons.entries()) {\r\n      this._navPolygons.push(new NavPoly(game, i, polygon));\r\n    }\r\n\r\n    this._calculateNeighbors();\r\n\r\n    // Astar graph of connections between polygons\r\n    this._graph = new NavGraph(this._navPolygons);\r\n  }\r\n\r\n  /**\r\n   * Cleanup method to remove references so that navmeshes don't hang around from state to state.\r\n   * You don't have to invoke this directly. If you call destroy on the plugin, it will destroy\r\n   * all navmeshes that have been created. \r\n   * \r\n   * @memberof NavMesh\r\n   */\r\n  destroy() {\r\n    this._graph.destroy();\r\n    for (const poly of this._navPolygons) poly.destroy();\r\n    this._navPolygons = [];\r\n    this.game = null;\r\n    this.disableDebug();\r\n  }\r\n\r\n  /**\r\n   * Find a path from the start point to the end point using this nav mesh.\r\n   *\r\n   * @param {Phaser.Point} startPoint\r\n   * @param {Phaser.Point} endPoint\r\n   * @param {object} [drawOptions={}] Options for controlling debug drawing\r\n   * @param {boolean} [drawOptions.drawPolyPath=false] Whether or not to visualize the path\r\n   * through the polygons - e.g. the path that astar found.\r\n   * @param {boolean} [drawOptions.drawFinalPath=false] Whether or not to visualize the path\r\n   * through the path that was returned.\r\n   * @returns {Phaser.Point[]|null} An array of points if a path is found, or null if no path\r\n   *\r\n   * @memberof NavMesh\r\n   */\r\n  findPath(startPoint, endPoint, { drawPolyPath = false, drawFinalPath = false } = {}) {\r\n    let startPoly = null;\r\n    let endPoly = null;\r\n    let startDistance = Number.MAX_VALUE;\r\n    let endDistance = Number.MAX_VALUE;\r\n    let d, r;\r\n\r\n    // Find the closest poly for the starting and ending point\r\n    for (const navPoly of this._navPolygons) {\r\n      r = navPoly.boundingRadius;\r\n      // Start\r\n      d = navPoly.centroid.distance(startPoint);\r\n      if (d <= startDistance && d <= r && navPoly.contains(startPoint)) {\r\n        startPoly = navPoly;\r\n        startDistance = d;\r\n      }\r\n      // End\r\n      d = navPoly.centroid.distance(endPoint);\r\n      if (d <= endDistance && d <= r && navPoly.contains(endPoint)) {\r\n        endPoly = navPoly;\r\n        endDistance = d;\r\n      }\r\n    }\r\n\r\n    // If the start point wasn't inside a polygon, run a more liberal check that allows a point\r\n    // to be within meshShrinkAmount radius of a polygon\r\n    if (!startPoly && this._meshShrinkAmount > 0) {\r\n      for (const navPoly of this._navPolygons) {\r\n        // Check if point is within bounding circle to avoid extra projection calculations\r\n        r = navPoly.boundingRadius + this._meshShrinkAmount;\r\n        d = navPoly.centroid.distance(startPoint);\r\n        if (d <= r) {\r\n          // Check if projected point is within range of a polgyon and is closer than the\r\n          // previous point\r\n          const { distance } = this._projectPointToPolygon(startPoint, navPoly);\r\n          if (distance <= this._meshShrinkAmount && distance < startDistance) {\r\n            startPoly = navPoly;\r\n            startDistance = distance;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Same check as above, but for the end point\r\n    if (!endPoly && this._meshShrinkAmount > 0) {\r\n      for (const navPoly of this._navPolygons) {\r\n        r = navPoly.boundingRadius + this._meshShrinkAmount;\r\n        d = navPoly.centroid.distance(endPoint);\r\n        if (d <= r) {\r\n          const { distance } = this._projectPointToPolygon(endPoint, navPoly);\r\n          if (distance <= this._meshShrinkAmount && distance < endDistance) {\r\n            endPoly = navPoly;\r\n            endDistance = distance;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // No matching polygons locations for the start or end, so no path found\r\n    if (!startPoly || !endPoly) return null;\r\n\r\n    // If the start and end polygons are the same, return a direct path\r\n    if (startPoly === endPoly) {\r\n      const phaserPath = [startPoint.clone(), endPoint.clone()];\r\n      if (drawFinalPath) this.debugDrawPath(phaserPath, 0xffd900, 10);\r\n      return phaserPath;\r\n    }\r\n\r\n    // Search!\r\n    const astarPath = jsastar.astar.search(this._graph, startPoly, endPoly, {\r\n      heuristic: this._graph.navHeuristic\r\n    });\r\n\r\n    // While the start and end polygons may be valid, no path between them\r\n    if (astarPath.length === 0) return null;\r\n\r\n    // jsastar drops the first point from the path, but the funnel algorithm needs it\r\n    astarPath.unshift(startPoly);\r\n\r\n    // We have a path, so now time for the funnel algorithm\r\n    const channel = new Channel();\r\n    channel.push(startPoint);\r\n    for (let i = 0; i < astarPath.length - 1; i++) {\r\n      const navPolygon = astarPath[i];\r\n      const nextNavPolygon = astarPath[i + 1];\r\n\r\n      // Find the portal\r\n      let portal = null;\r\n      for (let i = 0; i < navPolygon.neighbors.length; i++) {\r\n        if (navPolygon.neighbors[i].id === nextNavPolygon.id) {\r\n          portal = navPolygon.portals[i];\r\n        }\r\n      }\r\n\r\n      // Push the portal vertices into the channel\r\n      channel.push(portal.start, portal.end);\r\n    }\r\n    channel.push(endPoint);\r\n\r\n    // Pull a string along the channel to run the funnel\r\n    channel.stringPull();\r\n\r\n    // Clone path, excluding duplicates\r\n    let lastPoint = null;\r\n    const phaserPath = [];\r\n    for (const p of channel.path) {\r\n      const newPoint = p.clone();\r\n      if (!lastPoint || !newPoint.equals(lastPoint)) phaserPath.push(newPoint);\r\n      lastPoint = newPoint;\r\n    }\r\n\r\n    // Call debug drawing\r\n    if (drawPolyPath) {\r\n      const polyPath = astarPath.map(elem => elem.centroid);\r\n      this.debugDrawPath(polyPath, 0x00ff00, 5);\r\n    }\r\n    if (drawFinalPath) this.debugDrawPath(phaserPath, 0xffd900, 10);\r\n\r\n    return phaserPath;\r\n  }\r\n\r\n  _calculateNeighbors() {\r\n    // Fill out the neighbor information for each navpoly\r\n    for (let i = 0; i < this._navPolygons.length; i++) {\r\n      const navPoly = this._navPolygons[i];\r\n\r\n      for (let j = i + 1; j < this._navPolygons.length; j++) {\r\n        const otherNavPoly = this._navPolygons[j];\r\n\r\n        // Check if the other navpoly is within range to touch\r\n        const d = navPoly.centroid.distance(otherNavPoly.centroid);\r\n        if (d > navPoly.boundingRadius + otherNavPoly.boundingRadius) continue;\r\n\r\n        // The are in range, so check each edge pairing\r\n        for (const edge of navPoly.edges) {\r\n          for (const otherEdge of otherNavPoly.edges) {\r\n            // If edges aren't collinear, not an option for connecting navpolys\r\n            if (!areCollinear(edge, otherEdge)) continue;\r\n\r\n            // If they are collinear, check if they overlap\r\n            const overlap = this._getSegmentOverlap(edge, otherEdge);\r\n            if (!overlap) continue;\r\n\r\n            // Connections are symmetric!\r\n            navPoly.neighbors.push(otherNavPoly);\r\n            otherNavPoly.neighbors.push(navPoly);\r\n\r\n            // Calculate the portal between the two polygons - this needs to be in\r\n            // counter-clockwise order, relative to each polygon\r\n            const [p1, p2] = overlap;\r\n            let edgeStartAngle = navPoly.centroid.angle(edge.start);\r\n            let a1 = navPoly.centroid.angle(overlap[0]);\r\n            let a2 = navPoly.centroid.angle(overlap[1]);\r\n            let d1 = angleDifference(edgeStartAngle, a1);\r\n            let d2 = angleDifference(edgeStartAngle, a2);\r\n            if (d1 < d2) {\r\n              navPoly.portals.push(new Phaser.Line(p1.x, p1.y, p2.x, p2.y));\r\n            } else {\r\n              navPoly.portals.push(new Phaser.Line(p2.x, p2.y, p1.x, p1.y));\r\n            }\r\n\r\n            edgeStartAngle = otherNavPoly.centroid.angle(otherEdge.start);\r\n            a1 = otherNavPoly.centroid.angle(overlap[0]);\r\n            a2 = otherNavPoly.centroid.angle(overlap[1]);\r\n            d1 = angleDifference(edgeStartAngle, a1);\r\n            d2 = angleDifference(edgeStartAngle, a2);\r\n            if (d1 < d2) {\r\n              otherNavPoly.portals.push(new Phaser.Line(p1.x, p1.y, p2.x, p2.y));\r\n            } else {\r\n              otherNavPoly.portals.push(new Phaser.Line(p2.x, p2.y, p1.x, p1.y));\r\n            }\r\n\r\n            // Two convex polygons shouldn't be connected more than once! (Unless\r\n            // there are unnecessary vertices...)\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Check two collinear line segments to see if they overlap by sorting the points.\r\n  // Algorithm source: http://stackoverflow.com/a/17152247\r\n  _getSegmentOverlap(line1, line2) {\r\n    const points = [\r\n      { line: line1, point: line1.start },\r\n      { line: line1, point: line1.end },\r\n      { line: line2, point: line2.start },\r\n      { line: line2, point: line2.end }\r\n    ];\r\n    points.sort(function(a, b) {\r\n      if (a.point.x < b.point.x) return -1;\r\n      else if (a.point.x > b.point.x) return 1;\r\n      else {\r\n        if (a.point.y < b.point.y) return -1;\r\n        else if (a.point.y > b.point.y) return 1;\r\n        else return 0;\r\n      }\r\n    });\r\n    // If the first two points in the array come from the same line, no overlap\r\n    const noOverlap = points[0].line === points[1].line;\r\n    // If the two middle points in the array are the same coordinates, then there is a\r\n    // single point of overlap.\r\n    const singlePointOverlap = points[1].point.equals(points[2].point);\r\n    if (noOverlap || singlePointOverlap) return null;\r\n    else return [points[1].point, points[2].point];\r\n  }\r\n\r\n  /**\r\n   * Project a point onto a polygon in the shortest distance possible.\r\n   * \r\n   * @param {Phaser.Point} point The point to project\r\n   * @param {NavPoly} navPoly The navigation polygon to test against\r\n   * @returns {{point: Phaser.Point, distance: number}}\r\n   * \r\n   * @private\r\n   * @memberof NavMesh\r\n   */\r\n  _projectPointToPolygon(point, navPoly) {\r\n    let closestProjection = null;\r\n    let closestDistance = Number.MAX_VALUE;\r\n    for (const edge of navPoly.edges) {\r\n      const projectedPoint = this._projectPointToEdge(point, edge);\r\n      const d = point.distance(projectedPoint);\r\n      if (closestProjection === null || d < closestDistance) {\r\n        closestDistance = d;\r\n        closestProjection = projectedPoint;\r\n      }\r\n    }\r\n    return { point: closestProjection, distance: closestDistance };\r\n  }\r\n\r\n  _distanceSquared(a, b) {\r\n    const dx = b.x - a.x;\r\n    const dy = b.y - a.y;\r\n    return dx * dx + dy * dy;\r\n  }\r\n\r\n  // Project a point onto a line segment\r\n  // JS Source: http://stackoverflow.com/questions/849211/shortest-distance-between-a-point-and-a-line-segment\r\n  _projectPointToEdge(point, line) {\r\n    const a = line.start;\r\n    const b = line.end;\r\n    // Consider the parametric equation for the edge's line, p = a + t (b - a). We want to find\r\n    // where our point lies on the line by solving for t:\r\n    //  t = [(p-a) . (b-a)] / |b-a|^2\r\n    const l2 = this._distanceSquared(a, b);\r\n    let t = ((point.x - a.x) * (b.x - a.x) + (point.y - a.y) * (b.y - a.y)) / l2;\r\n    // We clamp t from [0,1] to handle points outside the segment vw.\r\n    t = Phaser.Math.clamp(t, 0, 1);\r\n    // Project onto the segment\r\n    const p = new Phaser.Point(a.x + t * (b.x - a.x), a.y + t * (b.y - a.y));\r\n    return p;\r\n  }\r\n\r\n  /**\r\n   * Enable debug and create graphics overlay (if it hasn't already been created) \r\n   */\r\n  enableDebug() {\r\n    if (!this._debugGraphics) {\r\n      this._debugGraphics = this.game.add.graphics(0, 0);\r\n      this._debugGraphics.alpha = 0.5;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Disable debug and destroy associated graphics\r\n   */\r\n  disableDebug() {\r\n    if (this._debugGraphics) {\r\n      this._debugGraphics.destroy();\r\n      this._debugGraphics = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check whether debug is enabled\r\n   * \r\n   * @returns {boolean}\r\n   */\r\n  isDebugEnabled() {\r\n    return this._debugGraphics !== null;\r\n  }\r\n\r\n  /**\r\n   * Clear the debug overlay\r\n   */\r\n  debugClear() {\r\n    if (this._debugGraphics) this._debugGraphics.clear();\r\n  }\r\n\r\n  /**\r\n   * Visualize the polygons in the nav mesh as an overlay on top of the game\r\n   *\r\n   * @param {object} options\r\n   * @param {boolean} [options.drawCentroid=true] For each polygon, show the approx centroid\r\n   * @param {boolean} [options.drawBounds=false] For each polygon, show the bounding radius\r\n   * @param {boolean} [options.drawNeighbors=true] For each polygon, show the connections to\r\n   * neighbors\r\n   * @param {boolean} [options.drawPortals=true] For each polygon, show the portal edges\r\n   */\r\n  debugDrawMesh(\r\n    { drawCentroid = true, drawBounds = false, drawNeighbors = true, drawPortals = true } = {}\r\n  ) {\r\n    if (!this._debugGraphics) this.enableDebug();\r\n    // Visualize the navigation mesh\r\n    for (const navPoly of this._navPolygons) {\r\n      navPoly.draw(this._debugGraphics, drawCentroid, drawBounds, drawNeighbors, drawPortals);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Visualize a path (array of points) on the debug graphics overlay\r\n   * \r\n   * @param {Phaser.Point[]} path \r\n   * @param {number} [color=0x00FF00] \r\n   * @param {number} [thickness=10] \r\n   */\r\n  debugDrawPath(path, color = 0x00ff00, thickness = 10) {\r\n    if (!this._debugGraphics) this.enableDebug();\r\n    if (path.length) {\r\n      // Draw line for path\r\n      this._debugGraphics.lineStyle(thickness, color);\r\n      this._debugGraphics.drawShape(new Phaser.Polygon(...path));\r\n      this._debugGraphics.beginFill(color);\r\n      // Draw circle at start and end of path\r\n      const d = 0.5 * thickness;\r\n      this._debugGraphics.drawEllipse(path[0].x, path[0].y, d, d);\r\n      const lastPoint = path[path.length - 1];\r\n      this._debugGraphics.drawEllipse(lastPoint.x, lastPoint.y, d, d);\r\n      this._debugGraphics.endFill();\r\n    }\r\n  }\r\n}\r\n\r\nexport default NavMesh;\r\n\n\n\n// WEBPACK FOOTER //\n// ./nav-mesh.js","// Debug color palette\r\nconst palette = [0x00a0b0, 0x6a4a3c, 0xcc333f, 0xeb6841, 0xedc951];\r\n\r\n/**\r\n * A class that represents a navigable polygon in a navmesh. It is build from a Phaser.Polygon. It\r\n * has a drawing function to help visualize it's features:\r\n *  - polygon\r\n *  - neighbors - any navpolys that can be reached from this navpoly\r\n *  - portals - overlapping edges between neighbors\r\n *  - centroid - not a true centroid, just an approximation.\r\n *  - boundingRadius - the radius of a circle at the centroid that fits all the points of the poly \r\n * \r\n * It implements the properties and fields that javascript-astar needs - weight, toString, isWall\r\n * and getCost. See GPS test from astar repo for structure: \r\n * https://github.com/bgrins/javascript-astar/blob/master/test/tests.js\r\n *\r\n * @class NavPoly\r\n * @private\r\n */\r\nclass NavPoly {\r\n  /**\r\n   * Creates an instance of NavPoly.\r\n   * @param {Phaser.Game} game \r\n   * @param {number} id \r\n   * @param {Phaser.Polygon} polygon \r\n   * \r\n   * @memberof NavPoly\r\n   */\r\n  constructor(game, id, polygon) {\r\n    this.game = game;\r\n    this.id = id;\r\n    this.polygon = polygon;\r\n    this.edges = this._calculateEdges();\r\n    this.neighbors = [];\r\n    this.portals = [];\r\n    this.centroid = this._calculateCentroid();\r\n    this.boundingRadius = this._calculateRadius();\r\n\r\n    this.weight = 1; // jsastar property\r\n\r\n    const i = this.id % palette.length;\r\n    this._color = palette[i];\r\n  }\r\n\r\n  contains(point) {\r\n    // Phaser's polygon check doesn't handle when a point is on one of the edges of the line. Note:\r\n    // check numerical stability here. It would also be good to optimize this for different shapes.\r\n    return this.polygon.contains(point.x, point.y) || this._isPointOnEdge(point);\r\n  }\r\n\r\n  destroy() {\r\n    this.game = null;\r\n    this.neighbors = [];\r\n    this.portals = [];\r\n  }\r\n\r\n  // jsastar methods\r\n  toString() {\r\n    return `NavPoly(id: ${this.id} at: ${this.centroid})`;\r\n  }\r\n  isWall() {\r\n    return this.weight === 0;\r\n  }\r\n  centroidDistance(navPolygon) {\r\n    return this.centroid.distance(navPolygon.centroid);\r\n  }\r\n  getCost(navPolygon) {\r\n    return this.centroidDistance(navPolygon);\r\n  }\r\n\r\n  _calculateEdges() {\r\n    const points = this.polygon.points;\r\n    const edges = [];\r\n    for (let i = 1; i < points.length; i++) {\r\n      const p1 = points[i - 1];\r\n      const p2 = points[i];\r\n      edges.push(new Phaser.Line(p1.x, p1.y, p2.x, p2.y));\r\n    }\r\n    const first = points[0];\r\n    const last = points[points.length - 1];\r\n    edges.push(new Phaser.Line(first.x, first.y, last.x, last.y));\r\n    return edges;\r\n  }\r\n\r\n  _calculateCentroid() {\r\n    // NOTE: this is not actually the centroid, it's the average of the vertices - not the same\r\n    // thing!\r\n    const centroid = new Phaser.Point(0, 0);\r\n    const length = this.polygon.points.length;\r\n    for (const point of this.polygon.points) {\r\n      centroid.add(point.x, point.y);\r\n    }\r\n    centroid.divide(length, length);\r\n    return centroid;\r\n  }\r\n\r\n  _calculateRadius() {\r\n    let boundingRadius = 0;\r\n    for (const point of this.polygon.points) {\r\n      const d = this.centroid.distance(point);\r\n      if (d > boundingRadius) boundingRadius = d;\r\n    }\r\n    return boundingRadius;\r\n  }\r\n\r\n  _isPointOnEdge(point) {\r\n    for (const edge of this.edges) {\r\n      if (edge.pointOnSegment(point.x, point.y)) return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Draw the polygon to given graphics object\r\n   * \r\n   * @param {Phaser.Graphics} graphics \r\n   * @param {boolean} [drawCentroid=true] Show the approx centroid\r\n   * @param {boolean} [drawBounds=false] Show the bounding radius\r\n   * @param {boolean} [drawNeighbors=true] Show the connections to neighbors\r\n   * @param {boolean} [drawPortals=true] Show the portal edges\r\n   * \r\n   * @memberof NavPoly\r\n   */\r\n  draw(\r\n    graphics,\r\n    drawCentroid = true,\r\n    drawBounds = false,\r\n    drawNeighbors = true,\r\n    drawPortals = true\r\n  ) {\r\n    graphics.lineWidth = 0;\r\n    graphics.beginFill(this._color);\r\n    graphics.drawPolygon(this.polygon);\r\n    graphics.endFill();\r\n\r\n    if (drawCentroid) {\r\n      graphics.beginFill(0x000000);\r\n      graphics.drawEllipse(this.centroid.x, this.centroid.y, 4, 4);\r\n      graphics.endFill();\r\n    }\r\n\r\n    if (drawBounds) {\r\n      graphics.lineStyle(1, 0xffffff);\r\n      const r = this.boundingRadius;\r\n      graphics.drawEllipse(this.centroid.x, this.centroid.y, r, r);\r\n    }\r\n\r\n    if (drawNeighbors) {\r\n      graphics.lineStyle(2, 0x000000);\r\n      for (const n of this.neighbors) {\r\n        graphics.moveTo(this.centroid.x, this.centroid.y);\r\n        graphics.lineTo(n.centroid.x, n.centroid.y);\r\n      }\r\n    }\r\n\r\n    if (drawPortals) {\r\n      graphics.lineStyle(10, 0x000000);\r\n      for (const p of this.portals) {\r\n        graphics.moveTo(p.start.x, p.start.y);\r\n        graphics.lineTo(p.end.x, p.end.y);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport default NavPoly;\r\n\n\n\n// WEBPACK FOOTER //\n// ./nav-poly.js"],"sourceRoot":""}